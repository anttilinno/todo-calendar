---
phase: 03-todo-management
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/todolist/model.go
  - internal/todolist/keys.go
  - internal/todolist/styles.go
  - internal/app/model.go
  - internal/app/keys.go
  - internal/calendar/model.go
  - main.go
autonomous: true

must_haves:
  truths:
    - "User can add a floating todo by pressing 'a' and typing text"
    - "User can add a dated todo by pressing 'A' and typing text then date"
    - "User can mark a todo complete/incomplete with 'x'"
    - "User can delete a todo with 'd'"
    - "Right pane shows dated todos for the viewed month under a month header"
    - "Right pane shows floating todos under a separate 'Floating' header"
    - "User can navigate the todo list with j/k keys"
    - "Help bar at bottom shows context-sensitive keybindings"
    - "Switching calendar month updates the todo list filter"
    - "Pressing 'q' during text input types 'q', not quits (input mode isolation)"
  artifacts:
    - path: "internal/todolist/model.go"
      provides: "Full todo list Bubble Tea model with modes, CRUD, rendering"
      contains: "func (m Model) Update"
    - path: "internal/todolist/keys.go"
      provides: "Todo-specific keybindings with help.KeyMap interface"
      contains: "type KeyMap struct"
    - path: "internal/todolist/styles.go"
      provides: "Todo styling (completed, cursor, section headers)"
      contains: "lipgloss"
    - path: "internal/app/model.go"
      provides: "Root model with help.Model, store initialization, month sync"
      contains: "help.Model"
    - path: "internal/app/keys.go"
      provides: "App KeyMap with dynamic enable/disable for input mode"
      contains: "SetEnabled"
    - path: "internal/calendar/model.go"
      provides: "Exported Year() and Month() accessors"
      contains: "func (m Model) Year"
    - path: "main.go"
      provides: "Store initialization before app.New"
      contains: "store.NewStore"
  key_links:
    - from: "internal/todolist/model.go"
      to: "internal/store/store.go"
      via: "Model holds *store.Store for CRUD operations"
      pattern: "store\\.Store"
    - from: "internal/app/model.go"
      to: "internal/todolist/model.go"
      via: "Root model holds todolist.Model and forwards messages"
      pattern: "m\\.todoList"
    - from: "internal/app/model.go"
      to: "internal/calendar/model.go"
      via: "Month sync: calendar.Year()/Month() -> todoList.SetViewMonth()"
      pattern: "m\\.calendar\\.Year\\(\\)"
    - from: "internal/app/model.go"
      to: "bubbles/help"
      via: "help.Model renders context-sensitive keybindings"
      pattern: "m\\.help\\.View"
    - from: "main.go"
      to: "internal/store/store.go"
      via: "Store created and passed to app.New"
      pattern: "store\\.NewStore"
    - from: "internal/app/model.go"
      to: "internal/todolist/model.go"
      via: "Input mode disables quit binding"
      pattern: "IsInputting"
---

<objective>
Rewrite the todolist placeholder into a full todo management UI with add/complete/delete, date filtering, two-section rendering, and wire it into the app with help bar and calendar-todo month synchronization.

Purpose: This is the final plan that delivers the core product value -- users can actually manage todos alongside their calendar. It connects the store (Plan 01) to the UI and wires everything together.
Output: Working todo CRUD in the right pane, context-sensitive help bar, calendar month sync, full keyboard navigation.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-todo-management/03-RESEARCH.md
@.planning/phases/03-todo-management/03-01-SUMMARY.md

@internal/todolist/model.go
@internal/app/model.go
@internal/app/keys.go
@internal/app/styles.go
@internal/calendar/model.go
@internal/calendar/keys.go
@main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite todolist package with full CRUD, modes, and rendering</name>
  <files>
    internal/todolist/model.go
    internal/todolist/keys.go
    internal/todolist/styles.go
    internal/calendar/model.go
  </files>
  <action>
**A. Add Year/Month accessors to calendar model** (`internal/calendar/model.go`):
Add two exported methods (do NOT change any existing code):
```go
func (m Model) Year() int        { return m.year }
func (m Model) Month() time.Month { return m.month }
```
Also export the `Keys()` method so app can access calendar keybindings for help:
```go
func (m Model) Keys() KeyMap { return m.keys }
```

**B. Create `internal/todolist/keys.go`:**
Define `KeyMap` struct with bindings:
- `Up` (k, up arrow) -- "up" help text
- `Down` (j, down arrow) -- "down" help text
- `Add` (a) -- "add todo" help text
- `AddDated` (A, shift+a) -- "add dated" help text
- `Toggle` (x) -- "complete" help text
- `Delete` (d) -- "delete" help text
- `Confirm` (enter) -- "confirm" help text (enabled only in input mode)
- `Cancel` (esc) -- "cancel" help text (enabled only in input mode)

Implement `help.KeyMap` interface (`ShortHelp`, `FullHelp`).
Provide `DefaultKeyMap()` constructor.

**C. Create `internal/todolist/styles.go`:**
Define styles using Lip Gloss:
- `sectionHeaderStyle` -- bold, maybe subtle color
- `completedStyle` -- faint/strikethrough (use `lipgloss.NewStyle().Faint(true).Strikethrough(true)`)
- `cursorStyle` -- for the `>` indicator on selected item
- `dateStyle` -- subtle color for date suffix on dated todos
- `emptyStyle` -- faint style for "No todos" placeholder text

**D. Rewrite `internal/todolist/model.go`:**

1. **Mode enum:** `normalMode`, `inputMode`, `dateInputMode`
   - `normalMode`: navigate, complete, delete
   - `inputMode`: typing todo text (press `a` for floating, `A` for dated)
   - `dateInputMode`: typing date after text (only for dated todos)

2. **Model struct:**
   ```go
   type Model struct {
       focused    bool
       width      int
       height     int
       mode       mode
       cursor     int              // index into visible items
       input      textinput.Model  // for text input
       store      *store.Store
       viewYear   int
       viewMonth  time.Month
       addingDated bool            // true if current add will have a date
       keys       KeyMap
   }
   ```

3. **New(s *store.Store) Model** -- constructor accepts store. Initialize textinput with `Placeholder: "What needs doing?"`, `CharLimit: 120`, `Prompt: "> "`. Do NOT focus the input yet. Set initial viewYear/viewMonth from `time.Now()`.

4. **SetFocused(f bool)** -- existing pattern.

5. **SetViewMonth(year int, month time.Month)** -- called by app when calendar month changes.

6. **IsInputting() bool** -- returns true if mode != normalMode. App uses this to suppress quit binding.

7. **HelpBindings() []key.Binding** -- returns context-appropriate bindings for help bar:
   - In normalMode: Up, Down, Add, AddDated, Toggle, Delete
   - In inputMode/dateInputMode: Confirm, Cancel

8. **visibleItems() []visibleItem** -- internal helper that builds the combined list:
   - First: month header (non-selectable) like "February 2026"
   - Then: dated todos for viewYear/viewMonth from `store.TodosForMonth()`
   - If no dated todos: "(no todos this month)" placeholder
   - Then: separator/floating header (non-selectable) "Floating"
   - Then: floating todos from `store.FloatingTodos()`
   - If no floating todos: "(no floating todos)" placeholder
   - Use a `visibleItem` struct with `kind` (header/todo/empty) and optional `todo` pointer

9. **Update(msg tea.Msg) (Model, tea.Cmd):**
   - **inputMode/dateInputMode:** Intercept Enter (confirm) and Escape (cancel) BEFORE forwarding to textinput. On Enter in inputMode: if `addingDated`, switch to dateInputMode (reset input, set placeholder to "YYYY-MM-DD", set prompt to "Date: "). On Enter in dateInputMode: parse date, call `store.Add(text, date)`, return to normalMode. On Enter in inputMode (not dated): call `store.Add(text, "")`, return to normalMode. On Escape: blur input, return to normalMode. Forward all other keys to `m.input.Update(msg)`.
   - **normalMode:** Handle keybindings:
     - Up/Down: move cursor, skip header/empty items
     - `a`: enter inputMode with `addingDated = false`, set placeholder "What needs doing?", focus input
     - `A`: enter inputMode with `addingDated = true`, same placeholder, focus input
     - `x`: if cursor is on a todo item, call `store.Toggle(todo.ID)`
     - `d`: if cursor is on a todo item, call `store.Delete(todo.ID)`, clamp cursor
   - After any delete: clamp cursor with `if m.cursor >= len(selectableItems) { m.cursor = max(0, len(selectableItems)-1) }`

10. **View() string:**
    - Build visible items list
    - Render each item:
      - Headers: sectionHeaderStyle with separator line
      - Todo items: `[x]` or `[ ]` prefix, text, optional date suffix. Apply completedStyle if done. Show `>` cursor on selected item.
      - Empty placeholders: emptyStyle
    - In input mode: show the text input at the bottom of the list
    - Truncate/scroll if items exceed available height (simple: show items around cursor, or just render all and let the pane clip)

Imports: `bubbles/textinput`, `bubbles/key`, `lipgloss`, `store`, `time`, `strings`, `fmt`.

**Critical pitfall avoidance:**
- In inputMode, do NOT let the textinput swallow Enter/Escape -- intercept them first
- After delete, ALWAYS clamp cursor index
- When cursor moves, skip non-selectable items (headers, empty placeholders)
  </action>
  <verify>
`cd /home/antti/Repos/Misc/todo-calendar && go build ./internal/todolist/... && go build ./internal/calendar/...` compiles without errors. `go vet ./internal/...` passes.
  </verify>
  <done>Todolist package has full Model with two modes (normal/input), CRUD operations via store, two-section rendering (dated + floating), cursor navigation, and help binding support. Calendar model exports Year()/Month()/Keys().</done>
</task>

<task type="auto">
  <name>Task 2: Wire todo UI into app with help bar, store init, and month sync</name>
  <files>
    internal/app/model.go
    internal/app/keys.go
    main.go
  </files>
  <action>
**A. Update `main.go`:**
- Import `store` package
- Before `app.New()`, call `store.TodosPath()` to get path, then `store.NewStore(path)` to load/create store
- Handle store error with stderr + exit (same pattern as config/provider errors)
- Pass store to `app.New(provider, mondayStart, store)` -- signature changes

**B. Update `internal/app/keys.go`:**
- No new bindings needed in app KeyMap (todo bindings live in todolist package)
- But add dynamic enable/disable: when todolist is in input mode, disable `Quit` binding so `q` goes to textinput not quit. Only `Ctrl+C` should still quit.
- Approach: split Quit into two bindings -- `Quit` (q, ctrl+c) for normal display, but at runtime use `m.keys.Quit.SetEnabled(!m.todoList.IsInputting())` in the Update method. Actually simpler: just check `IsInputting()` before matching Quit. If inputting and key is not ctrl+c, don't process quit.

Better approach (avoid modifying KeyMap struct): In `Update`, before checking `key.Matches(msg, m.keys.Quit)`, check if the todo pane is focused and inputting. If so, only quit on `ctrl+c`, not `q`. This avoids needing SetEnabled at all.

```go
case tea.KeyMsg:
    // In input mode, only ctrl+c quits (let 'q' go to textinput)
    isInputting := m.activePane == todoPane && m.todoList.IsInputting()
    if key.Matches(msg, m.keys.Quit) && !isInputting {
        return m, tea.Quit
    }
    if isInputting && msg.String() == "ctrl+c" {
        return m, tea.Quit
    }
```

**C. Update `internal/app/model.go`:**

1. **Import changes:** Add `bubbles/help`, `store` package.

2. **Model struct:** Add `help help.Model` field, `store *store.Store` field.

3. **New() signature:** Change to `New(provider *holidays.Provider, mondayStart bool, s *store.Store) Model`. Pass store to `todolist.New(s)`.

4. **Init():** Return `nil` (unchanged).

5. **help.Model setup in New:**
   ```go
   h := help.New()
   ```
   Store it in the model.

6. **WindowSizeMsg handler:** Add `m.help.Width = msg.Width`. Also set initial viewMonth on todoList:
   ```go
   m.todoList.SetViewMonth(m.calendar.Year(), m.calendar.Month())
   ```

7. **Month sync after calendar update:** In the key routing section, after `m.calendar, cmd = m.calendar.Update(msg)`, add:
   ```go
   m.todoList.SetViewMonth(m.calendar.Year(), m.calendar.Month())
   ```
   This ensures the todo list always shows todos for the calendar's viewed month.

8. **Tab handling:** When switching to todoPane, also call `m.todoList.SetViewMonth(m.calendar.Year(), m.calendar.Month())` to ensure sync.

9. **Help bar in View():** Replace the hardcoded `statusBar` string with:
   ```go
   m.help.Width = m.width
   helpBar := m.help.View(m.currentHelpKeys())
   ```
   Where `currentHelpKeys()` returns a `helpKeyMap` aggregating:
   - If calendarPane focused: calendar PrevMonth + NextMonth bindings
   - If todoPane focused: todoList.HelpBindings()
   - Always: Tab, Quit (from app keys)

10. **helpKeyMap type:** Create a small adapter type satisfying `help.KeyMap`:
    ```go
    type helpKeyMap struct { bindings []key.Binding }
    func (h helpKeyMap) ShortHelp() []key.Binding { return h.bindings }
    func (h helpKeyMap) FullHelp() [][]key.Binding { return [][]key.Binding{h.bindings} }
    ```

11. **Help height calculation:** The help bar may wrap. For simplicity, keep `helpHeight := 1` (help.Model truncates to width). This is fine.

**Key routing correctness:** Ensure that when todoPane is active:
- Tab still switches panes (handled at app level before routing to child)
- All other keys go to todoList.Update, which handles mode-specific routing internally
  </action>
  <verify>
`cd /home/antti/Repos/Misc/todo-calendar && go build ./...` compiles without errors. `go vet ./...` passes. Run the app with `go run .` to verify it starts without crash (manual smoke test). The help bar should show keybindings instead of the hardcoded string.
  </verify>
  <done>App starts with store loaded from disk, todo pane shows empty state with section headers, help bar shows context-sensitive keybindings, calendar month navigation updates todo filter, q is suppressed during text input, full build passes.</done>
</task>

</tasks>

<verification>
1. `go build ./...` -- entire project compiles
2. `go vet ./...` -- no issues
3. Run app (`go run .`):
   - Right pane shows "February 2026" header and "Floating" header with empty placeholders
   - Press Tab to focus todo pane, press `a`, type text, press Enter -- todo appears in floating section
   - Press `A`, type text, press Enter, type "2026-02-15", press Enter -- todo appears in dated section
   - Press `x` on a todo -- checkmark appears, text gets strikethrough/faint
   - Press `d` on a todo -- todo removed, cursor clamps
   - Press `q` during input -- types "q" instead of quitting
   - Navigate to next month with Tab -> left pane -> arrow -- dated todos filter changes
   - Help bar updates when switching panes
4. Quit and relaunch -- todos persisted
5. Check `~/.config/todo-calendar/todos.json` exists with correct JSON structure
</verification>

<success_criteria>
- All 8 requirements covered: TODO-01 through TODO-05, DATA-01, DATA-03, UI-03
- User can add, complete, delete todos with keyboard
- Two-section display (dated by month + floating)
- Help bar shows context-sensitive keybindings
- Todos persist across restarts as JSON
- Calendar month sync works
- No panics on edge cases (empty list, delete last item, narrow terminal)
</success_criteria>

<output>
After completion, create `.planning/phases/03-todo-management/03-02-SUMMARY.md`
</output>

---
phase: 05-todo-editing
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - internal/todolist/model.go
autonomous: true

must_haves:
  truths:
    - "User can press e on a selected todo to enter edit mode with existing text pre-filled"
    - "User can modify the pre-filled text and press Enter to confirm the edit"
    - "User can press E on a selected todo to enter date edit mode with existing date pre-filled"
    - "User can clear the date input and press Enter to make a dated todo floating"
    - "User can type a new date and press Enter to change a todo's date"
    - "Pressing Escape in edit mode cancels without saving changes"
    - "Edited todos persist to disk immediately (survive app restart)"
    - "Help bar shows e/E bindings in normal mode"
  artifacts:
    - path: "internal/todolist/model.go"
      provides: "editTextMode and editDateMode constants, editingID field, edit handlers"
      contains: "editTextMode"
    - path: "internal/todolist/model.go"
      provides: "updateEditTextMode handler function"
      contains: "func (m Model) updateEditTextMode"
    - path: "internal/todolist/model.go"
      provides: "updateEditDateMode handler function"
      contains: "func (m Model) updateEditDateMode"
  key_links:
    - from: "internal/todolist/model.go updateEditTextMode"
      to: "store.Update"
      via: "m.store.Update(m.editingID, text, todo.Date)"
      pattern: "m\\.store\\.Update"
    - from: "internal/todolist/model.go updateEditDateMode"
      to: "store.Update"
      via: "m.store.Update(m.editingID, todo.Text, date)"
      pattern: "m\\.store\\.Update"
    - from: "internal/todolist/model.go updateEditTextMode"
      to: "store.Find"
      via: "m.store.Find(m.editingID) to get non-edited field"
      pattern: "m\\.store\\.Find"
    - from: "internal/todolist/model.go updateNormalMode"
      to: "m.keys.Edit"
      via: "key.Matches triggers edit text mode"
      pattern: "key\\.Matches.*m\\.keys\\.Edit"
    - from: "internal/todolist/model.go HelpBindings"
      to: "m.keys.Edit, m.keys.EditDate"
      via: "included in normal mode help bindings"
      pattern: "m\\.keys\\.Edit.*m\\.keys\\.EditDate"
---

<objective>
Implement edit text and edit date modes in the todolist model, wiring the new store methods and key bindings from Plan 01 into working edit flows.

Purpose: This is the core of Phase 5 -- letting users modify existing todos. Pressing `e` pre-fills the text input with the selected todo's text for editing. Pressing `E` pre-fills with the existing date (or empty for floating). Both flows call `store.Update()` on confirm and persist immediately.
Output: Modified model.go with complete edit text and edit date functionality.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-todo-editing/05-RESEARCH.md
@.planning/phases/05-todo-editing/05-01-SUMMARY.md

@internal/todolist/model.go
@internal/todolist/keys.go
@internal/store/store.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add edit modes, editingID field, and mode routing</name>
  <files>internal/todolist/model.go</files>
  <action>
1. Add two new mode constants after `dateInputMode`:
   ```
   editTextMode       // editing existing todo text
   editDateMode       // editing existing todo date
   ```

2. Add `editingID int` field to the Model struct (after `pendingText`). This tracks which todo is being edited.

3. In the Update method's KeyMsg switch on m.mode, add routing for the two new modes BEFORE the `default` case:
   ```
   case editTextMode:
       return m.updateEditTextMode(msg)
   case editDateMode:
       return m.updateEditDateMode(msg)
   ```

4. In `updateNormalMode`, add two new key match cases AFTER the Delete case:

   For `m.keys.Edit`:
   - Guard: `if len(selectable) > 0 && m.cursor < len(selectable)` (same pattern as Toggle/Delete)
   - Get the selected todo via `items[selectable[m.cursor]].todo`
   - Set `m.editingID = todo.ID`
   - Set `m.mode = editTextMode`
   - Set input placeholder to `"Edit todo text"`, prompt to `"> "`
   - Call `m.input.SetValue(todo.Text)` then `m.input.CursorEnd()`
   - Return `m, m.input.Focus()`

   For `m.keys.EditDate`:
   - Same guard pattern
   - Get the selected todo
   - Set `m.editingID = todo.ID`
   - Set `m.mode = editDateMode`
   - Set input placeholder to `"YYYY-MM-DD (empty = floating)"`, prompt to `"Date: "`
   - Call `m.input.SetValue(todo.Date)` then `m.input.CursorEnd()` -- this pre-fills with existing date or empty string for floating todos
   - Return `m, m.input.Focus()`

5. Update `HelpBindings()` to include `m.keys.Edit` and `m.keys.EditDate` in the normal mode return, after Toggle and before Delete (or after Delete -- match natural order):
   ```
   return []key.Binding{m.keys.Up, m.keys.Down, m.keys.Add, m.keys.AddDated, m.keys.Edit, m.keys.EditDate, m.keys.Toggle, m.keys.Delete}
   ```
  </action>
  <verify>Run `cd /home/antti/Repos/Misc/todo-calendar && go build ./...` -- must compile cleanly.</verify>
  <done>Edit modes route correctly, e/E keys enter edit modes with pre-filled input, help bar shows edit bindings.</done>
</task>

<task type="auto">
  <name>Task 2: Implement edit text and edit date confirmation handlers</name>
  <files>internal/todolist/model.go</files>
  <action>
Add two new handler functions after `updateDateInputMode`:

1. `func (m Model) updateEditTextMode(msg tea.KeyMsg) (Model, tea.Cmd)`:
   - On Confirm (Enter):
     - Get trimmed text from input. If empty, return m, nil (don't save empty text -- same guard as add flow).
     - Call `m.store.Find(m.editingID)` to get the todo's current state (specifically its Date, which is the non-edited field).
     - If todo found (not nil), call `m.store.Update(m.editingID, text, todo.Date)` -- this preserves the original date while updating text.
     - Reset: `m.mode = normalMode`, `m.input.Blur()`, `m.input.SetValue("")`
     - Return m, nil
   - On Cancel (Escape):
     - Reset: `m.mode = normalMode`, `m.input.Blur()`, `m.input.SetValue("")`
     - Return m, nil
   - Default: forward to `m.input.Update(msg)`, return updated model + cmd

2. `func (m Model) updateEditDateMode(msg tea.KeyMsg) (Model, tea.Cmd)`:
   - On Confirm (Enter):
     - Get trimmed date from input.
     - If date is NOT empty, validate with `time.Parse("2006-01-02", date)`. If invalid, return m, nil (stay in edit mode).
     - If date IS empty, this is valid -- it means "make floating" (remove date). Do NOT reject empty.
     - Call `m.store.Find(m.editingID)` to get the todo's current Text.
     - If todo found, call `m.store.Update(m.editingID, todo.Text, date)`.
     - Reset: `m.mode = normalMode`, `m.input.Blur()`, `m.input.SetValue("")`
     - IMPORTANT: After date edit, the todo may have moved between sections (dated to floating or vice versa). Clamp the cursor:
       ```
       newSelectable := selectableIndices(m.visibleItems())
       if m.cursor >= len(newSelectable) {
           m.cursor = max(0, len(newSelectable)-1)
       }
       ```
     - Return m, nil
   - On Cancel (Escape):
     - Reset: same as edit text cancel
     - Return m, nil
   - Default: forward to `m.input.Update(msg)`, return updated model + cmd

Key differences from add flow to remember:
- Edit text: empty text rejected (same as add). Non-edited field (Date) preserved via Find.
- Edit date: empty input ACCEPTED (means "make floating"). This differs from dateInputMode for new todos where empty was rejected.
- After date edit: cursor clamped because todo may move between sections.
  </action>
  <verify>
1. `cd /home/antti/Repos/Misc/todo-calendar && go build ./...` -- compiles cleanly
2. `go vet ./...` -- no issues
3. Run the app manually: `go run .` -- test:
   a. Add a floating todo with `a`, type text, Enter
   b. Press `e` on it -- input should show existing text, cursor at end
   c. Modify text, press Enter -- todo text updates
   d. Press `E` on it -- input should be empty (no date)
   e. Type a date like 2026-02-15, Enter -- todo moves to dated section
   f. Press `E` again -- input shows 2026-02-15
   g. Clear input, press Enter -- todo moves back to floating
   h. Press Escape during edit -- no changes saved
  </verify>
  <done>
- Pressing e pre-fills todo text, Enter saves modified text, Escape cancels
- Pressing E pre-fills todo date (or empty for floating), Enter saves modified date, empty input makes todo floating
- Edited todos persist to disk immediately (store.Update calls Save)
- Cursor clamped after date edit when todo moves between sections
- Empty text rejected on edit confirm (same as add)
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` and `go vet ./...` pass
2. Grep confirms edit mode constants: `grep "editTextMode\|editDateMode" internal/todolist/model.go`
3. Grep confirms handler functions: `grep "func.*updateEdit" internal/todolist/model.go`
4. Grep confirms store wiring: `grep "m.store.Update\|m.store.Find" internal/todolist/model.go`
5. Manual test: full edit text and edit date flows work end-to-end
6. Manual test: app restart after edit shows persisted changes
</verification>

<success_criteria>
- EDIT-01: User presses e, sees pre-filled text, modifies, confirms with Enter -- text saved
- EDIT-02: User presses E, sees pre-filled date, can change date or clear to make floating -- date saved
- EDIT-03: All edits persist to disk immediately (survive app restart)
- Escape cancels without saving
- Empty text on edit confirm is rejected
- Cursor clamped after date edit moves todo between sections
- Help bar shows e/E bindings in normal mode
</success_criteria>

<output>
After completion, create `.planning/phases/05-todo-editing/05-02-SUMMARY.md`
</output>

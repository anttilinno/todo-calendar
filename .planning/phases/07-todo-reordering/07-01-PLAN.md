---
phase: 07-todo-reordering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/store/todo.go
  - internal/store/store.go
autonomous: true

must_haves:
  truths:
    - "Todo struct has a SortOrder field that persists to JSON"
    - "Legacy todos without sort_order get unique values on load"
    - "Dated todos sort by SortOrder first, then date, then ID"
    - "Floating todos sort by SortOrder first, then ID"
    - "New todos get a SortOrder placing them at end of list"
    - "SwapOrder exchanges sort order of two todos and persists"
  artifacts:
    - path: "internal/store/todo.go"
      provides: "SortOrder field on Todo struct"
      contains: "SortOrder int"
    - path: "internal/store/store.go"
      provides: "EnsureSortOrder, SwapOrder methods, updated sort logic, updated Add"
      contains: "func (s *Store) SwapOrder"
  key_links:
    - from: "internal/store/store.go"
      to: "internal/store/todo.go"
      via: "SortOrder field used in sort comparators"
      pattern: "SortOrder"
    - from: "internal/store/store.go (NewStore)"
      to: "internal/store/store.go (EnsureSortOrder)"
      via: "called after load to migrate legacy data"
      pattern: "EnsureSortOrder"
    - from: "internal/store/store.go (Add)"
      to: "internal/store/todo.go (SortOrder)"
      via: "new todos get maxOrder + 10"
      pattern: "SortOrder.*maxOrder"
---

<objective>
Add sort order data model and store methods for todo reordering.

Purpose: Provides the data layer foundation for manual todo reordering. Without SortOrder on the Todo struct and SwapOrder on the Store, the UI layer has nothing to call.
Output: Updated Todo struct with SortOrder field, EnsureSortOrder migration, SwapOrder method, updated sort functions, updated Add method.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-todo-reordering/07-RESEARCH.md
@internal/store/todo.go
@internal/store/store.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SortOrder field and update sort logic</name>
  <files>internal/store/todo.go, internal/store/store.go</files>
  <action>
1. In `internal/store/todo.go`, add `SortOrder int` field to the `Todo` struct with JSON tag `json:"sort_order,omitempty"`. Place it after `CreatedAt`. The `omitempty` tag ensures legacy JSON files without this field load cleanly (Go defaults missing int to 0), and existing todos with SortOrder 0 do not emit the field unnecessarily.

2. In `internal/store/store.go`, add `EnsureSortOrder()` method on `*Store`:
   - Iterates over `s.data.Todos`
   - For any todo with `SortOrder == 0`, assigns `(i + 1) * 10` (using loop index)
   - If any changes were made, calls `s.Save()`
   - This is a one-time migration for legacy data

3. In `internal/store/store.go`, call `s.EnsureSortOrder()` in `NewStore()` after `s.load()` succeeds (before the return statement).

4. Update `TodosForMonth()` sort function to use SortOrder as primary key:
   ```
   SortOrder ascending, then Date ascending, then ID ascending
   ```

5. Update `FloatingTodos()` sort function to use SortOrder as primary key:
   ```
   SortOrder ascending, then ID ascending
   ```

6. Update `Add()` to assign SortOrder to new todos:
   - Find max SortOrder across all existing todos
   - Set new todo's SortOrder to `maxOrder + 10`
   - This places new todos at the end of whatever section they belong to

7. Add `SwapOrder(id1, id2 int)` method on `*Store`:
   - Find both todos by ID using pointer-to-slice-element pattern (like `Find`)
   - Swap their `SortOrder` values
   - Call `s.Save()`
   - If either ID not found, do nothing (silent no-op, consistent with Toggle/Delete pattern)
  </action>
  <verify>
Run `go build ./...` -- must compile without errors.
Run `go vet ./...` -- no warnings.
Manually inspect that `EnsureSortOrder` is called in `NewStore`, `SwapOrder` exists, sort functions use SortOrder as primary key, and `Add` assigns SortOrder.
  </verify>
  <done>
Todo struct has SortOrder field with JSON tag. NewStore calls EnsureSortOrder after load. TodosForMonth and FloatingTodos sort by SortOrder first. Add assigns maxOrder+10. SwapOrder swaps two todos' SortOrder values and persists. `go build ./...` passes.
  </done>
</task>

</tasks>

<verification>
- `go build ./...` passes
- `go vet ./...` passes
- `grep -n "SortOrder" internal/store/todo.go` shows the field
- `grep -n "SwapOrder" internal/store/store.go` shows the method
- `grep -n "EnsureSortOrder" internal/store/store.go` shows the migration method and its call in NewStore
</verification>

<success_criteria>
- Todo struct includes `SortOrder int` with `json:"sort_order,omitempty"` tag
- EnsureSortOrder assigns unique values to legacy todos on load
- TodosForMonth sorts by SortOrder > Date > ID
- FloatingTodos sorts by SortOrder > ID
- Add sets SortOrder = maxOrder + 10
- SwapOrder exchanges SortOrder of two todos by ID and persists
- All code compiles and passes vet
</success_criteria>

<output>
After completion, create `.planning/phases/07-todo-reordering/07-01-SUMMARY.md`
</output>

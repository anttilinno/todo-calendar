---
phase: 07-todo-reordering
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - internal/todolist/keys.go
  - internal/todolist/model.go
autonomous: true

must_haves:
  truths:
    - "User can move the selected todo one position up via Shift+K"
    - "User can move the selected todo one position down via Shift+J"
    - "Move is a no-op at section boundaries (dated todo cannot swap with floating)"
    - "Cursor follows the moved todo after swap"
    - "Reorder keybindings K/J appear in help bar during normal mode"
  artifacts:
    - path: "internal/todolist/keys.go"
      provides: "MoveUp and MoveDown key bindings"
      contains: "MoveUp"
    - path: "internal/todolist/model.go"
      provides: "Move handlers in updateNormalMode, updated HelpBindings"
      contains: "MoveUp"
  key_links:
    - from: "internal/todolist/model.go (updateNormalMode)"
      to: "internal/store/store.go (SwapOrder)"
      via: "m.store.SwapOrder call on move key press"
      pattern: "SwapOrder"
    - from: "internal/todolist/model.go (updateNormalMode)"
      to: "internal/store/todo.go (HasDate)"
      via: "section boundary check before swap"
      pattern: "HasDate.*HasDate"
    - from: "internal/todolist/model.go (HelpBindings)"
      to: "internal/todolist/keys.go (MoveUp, MoveDown)"
      via: "included in normal mode help bindings list"
      pattern: "MoveUp.*MoveDown"
---

<objective>
Wire todo reordering keybindings into the todolist UI component.

Purpose: Connects the store's SwapOrder method to user-facing keybindings so users can move todos up and down. Also updates the help bar to show the new keybindings.
Output: Working K/J (Shift+k/j) keybindings that reorder todos within sections, with help bar integration.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-todo-reordering/07-RESEARCH.md
@.planning/phases/07-todo-reordering/07-01-SUMMARY.md
@internal/todolist/keys.go
@internal/todolist/model.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MoveUp/MoveDown keybindings and handlers</name>
  <files>internal/todolist/keys.go, internal/todolist/model.go</files>
  <action>
1. In `internal/todolist/keys.go`:
   - Add `MoveUp key.Binding` and `MoveDown key.Binding` fields to the `KeyMap` struct (after `Down`, before `Add`)
   - In `DefaultKeyMap()`, initialize them:
     ```
     MoveUp: key.NewBinding(
         key.WithKeys("K"),
         key.WithHelp("K", "move up"),
     ),
     MoveDown: key.NewBinding(
         key.WithKeys("J"),
         key.WithHelp("J", "move down"),
     ),
     ```
     Note: Capital "K" and "J" means Shift+k and Shift+j. This follows the existing pattern where `a`/`A` and `e`/`E` use shift as a variant.
   - Update `ShortHelp()` to include `k.MoveUp, k.MoveDown` after `k.Down`
   - Update `FullHelp()` to include `k.MoveUp, k.MoveDown` after `k.Down`

2. In `internal/todolist/model.go`, in `updateNormalMode()`:
   - Add two new cases in the switch block (after the `key.Matches(msg, m.keys.Up)` case):

   For MoveUp:
   - Check `len(selectable) > 0 && m.cursor > 0 && m.cursor < len(selectable)`
   - Get `curIdx := selectable[m.cursor]` and `prevIdx := selectable[m.cursor-1]`
   - Get `curTodo := items[curIdx].todo` and `prevTodo := items[prevIdx].todo`
   - Section boundary check: both todos must be non-nil AND `curTodo.HasDate() == prevTodo.HasDate()`
   - If valid: call `m.store.SwapOrder(curTodo.ID, prevTodo.ID)` and decrement `m.cursor--`
   - If boundary mismatch: no-op (do nothing)

   For MoveDown:
   - Check `len(selectable) > 0 && m.cursor >= 0 && m.cursor < len(selectable)-1`
   - Get `curIdx := selectable[m.cursor]` and `nextIdx := selectable[m.cursor+1]`
   - Get `curTodo := items[curIdx].todo` and `nextTodo := items[nextIdx].todo`
   - Section boundary check: both todos must be non-nil AND `curTodo.HasDate() == nextTodo.HasDate()`
   - If valid: call `m.store.SwapOrder(curTodo.ID, nextTodo.ID)` and increment `m.cursor++`
   - If boundary mismatch: no-op (do nothing)

3. In `internal/todolist/model.go`, update `HelpBindings()`:
   - In the normal mode return, add `m.keys.MoveUp, m.keys.MoveDown` after `m.keys.Down`:
     ```go
     return []key.Binding{m.keys.Up, m.keys.Down, m.keys.MoveUp, m.keys.MoveDown, m.keys.Add, m.keys.AddDated, m.keys.Edit, m.keys.EditDate, m.keys.Toggle, m.keys.Delete}
     ```

IMPORTANT: The `visibleItems()` method returns copies of todos (not pointers to store data). Use `todo.ID` for identification, not pointer equality. This is consistent with how Toggle, Delete, and Update work.

IMPORTANT: Do NOT add move handling in any mode other than normalMode. Reorder keys only work when navigating, not when typing.
  </action>
  <verify>
Run `go build ./...` -- must compile without errors.
Run `go vet ./...` -- no warnings.
Run the app with `go run .` and test:
1. Add 2-3 floating todos, select one, press Shift+J to move down, Shift+K to move up
2. Add 2-3 dated todos, verify move works within dated section
3. At the boundary between dated and floating sections, verify move is a no-op
4. Verify cursor follows the moved item
5. Verify K/J appear in the help bar
6. Quit and restart the app -- verify the custom order persists
  </verify>
  <done>
Shift+K moves selected todo up within its section. Shift+J moves selected todo down within its section. Section boundaries are enforced (no cross-section swaps). Cursor follows moved item. K/J keybindings appear in help bar in normal mode. Order persists across app restart.
  </done>
</task>

</tasks>

<verification>
- `go build ./...` passes
- `go vet ./...` passes
- `grep -n "MoveUp\|MoveDown" internal/todolist/keys.go` shows both bindings
- `grep -n "MoveUp\|MoveDown" internal/todolist/model.go` shows handlers and help bindings
- `grep -n "SwapOrder" internal/todolist/model.go` shows the store call
- `grep -n "HasDate" internal/todolist/model.go` shows section boundary check
- Manual test: reorder todos with K/J, restart app, order preserved
</verification>

<success_criteria>
- K (Shift+k) moves selected todo up within its section
- J (Shift+j) moves selected todo down within its section
- Move at section top/bottom boundary is a no-op
- Cursor follows the moved todo
- K/J keybindings visible in help bar during normal mode
- Reordered todos maintain their position after app restart
- All success criteria from Phase 7 roadmap met:
  1. User can move the selected todo one position up in the list via keybinding
  2. User can move the selected todo one position down in the list via keybinding
  3. Custom todo order survives app restart (order is persisted in JSON)
  4. Reorder keybindings appear in the help bar when a todo is selected
</success_criteria>

<output>
After completion, create `.planning/phases/07-todo-reordering/07-02-SUMMARY.md`
</output>

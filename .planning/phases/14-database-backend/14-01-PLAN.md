---
phase: 14-database-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/store/store.go
  - internal/app/model.go
  - internal/calendar/model.go
  - internal/calendar/grid.go
  - internal/todolist/model.go
  - internal/search/model.go
  - main.go
autonomous: true

must_haves:
  truths:
    - "All store consumers reference the TodoStore interface, not the concrete Store struct"
    - "The app compiles and runs identically to before the refactor"
    - "The existing JSON backend satisfies the new interface implicitly"
  artifacts:
    - path: "internal/store/store.go"
      provides: "TodoStore interface definition"
      contains: "type TodoStore interface"
    - path: "internal/app/model.go"
      provides: "Root model using interface"
      contains: "store.TodoStore"
    - path: "internal/calendar/model.go"
      provides: "Calendar model using interface"
      contains: "store.TodoStore"
    - path: "internal/calendar/grid.go"
      provides: "RenderWeekGrid using interface"
      contains: "store.TodoStore"
    - path: "internal/todolist/model.go"
      provides: "Todolist model using interface"
      contains: "store.TodoStore"
    - path: "internal/search/model.go"
      provides: "Search model using interface"
      contains: "store.TodoStore"
  key_links:
    - from: "internal/store/store.go"
      to: "all consumer models"
      via: "TodoStore interface satisfied by *Store"
      pattern: "type TodoStore interface"
---

<objective>
Extract a TodoStore interface from the concrete store.Store struct and update all consumers to depend on the interface instead of the concrete type.

Purpose: Decouple store consumers from the JSON backend so a SQLite implementation can be swapped in without changing any consumer code. This is the prerequisite for DB-01 (SQLite storage) and DB-02 (store interface extraction).

Output: TodoStore interface defined in store package; all 5 consumer packages (app, calendar, todolist, search) and main.go reference the interface type.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/store/store.go
@internal/store/todo.go
@internal/app/model.go
@internal/calendar/model.go
@internal/calendar/grid.go
@internal/todolist/model.go
@internal/search/model.go
@main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define TodoStore interface in store package</name>
  <files>internal/store/store.go</files>
  <action>
Add a `TodoStore` interface at the top of `internal/store/store.go` (before the Store struct) that captures every public method on *Store that consumers use:

```go
// TodoStore defines the contract for todo persistence.
// Consumers depend on this interface, not the concrete backend.
type TodoStore interface {
    Add(text string, date string) Todo
    Toggle(id int)
    Delete(id int)
    Find(id int) *Todo
    Update(id int, text string, date string)
    Todos() []Todo
    TodosForMonth(year int, month time.Month) []Todo
    FloatingTodos() []Todo
    IncompleteTodosPerDay(year int, month time.Month) map[int]int
    TodoCountsByMonth() []MonthCount
    FloatingTodoCounts() FloatingCount
    SwapOrder(id1, id2 int)
    SearchTodos(query string) []Todo
    EnsureSortOrder()
    Save() error
}
```

Add `"time"` to the import block if not already present (it is already imported). The existing `*Store` struct already has all these methods as pointer receivers, so it implicitly satisfies this interface. No changes to the Store struct or its methods.
  </action>
  <verify>Run `go build ./...` from the project root. Must compile without errors. The concrete `*Store` must satisfy `TodoStore` -- verify with `var _ TodoStore = (*Store)(nil)` (add this as a compile-time check at the top of store.go, right after the interface definition).</verify>
  <done>TodoStore interface exists in store package. Compile-time check `var _ TodoStore = (*Store)(nil)` passes.</done>
</task>

<task type="auto">
  <name>Task 2: Change all consumers from *store.Store to store.TodoStore</name>
  <files>
    internal/app/model.go
    internal/calendar/model.go
    internal/calendar/grid.go
    internal/todolist/model.go
    internal/search/model.go
    main.go
  </files>
  <action>
Perform a mechanical find-and-replace across all consumer files. For each file:

**internal/app/model.go:**
1. Change field `store *store.Store` to `store store.TodoStore` (line 49)
2. Change `New` parameter `s *store.Store` to `s store.TodoStore` (line 55)

**internal/calendar/model.go:**
1. Change field `store *store.Store` to `store store.TodoStore` (line 48)
2. Change `New` parameter `s *store.Store` to `s store.TodoStore` (line 58)

**internal/calendar/grid.go:**
1. Change `RenderWeekGrid` parameter `st *store.Store` to `st store.TodoStore` (line 120)

**internal/todolist/model.go:**
1. Change field `store *store.Store` to `store store.TodoStore` (line 53)
2. Change `New` parameter `s *store.Store` to `s store.TodoStore` (line 67)

**internal/search/model.go:**
1. Change field `store *store.Store` to `store store.TodoStore` (line 32)
2. Change `New` parameter `s *store.Store` to `s store.TodoStore` (line 41)

**main.go:**
No changes needed -- main.go calls `store.NewStore()` which returns `*store.Store`. Since `*store.Store` satisfies `store.TodoStore`, and the consumers now accept the interface, the concrete type is passed at the call site and Go's implicit interface satisfaction handles the rest. The variable `s` in main.go can remain `*store.Store` since it is passed to functions that accept `store.TodoStore`.

These are all type changes only. No logic changes. No behavioral changes.
  </action>
  <verify>Run `go build ./...` -- must compile cleanly. Run `go vet ./...` -- no issues. Run the app manually to verify it starts and renders correctly: `go run .`</verify>
  <done>All 5 consumer packages reference `store.TodoStore` instead of `*store.Store`. App compiles and runs identically to before.</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go vet ./...` reports no issues
3. `grep -r '\*store\.Store' internal/` returns NO matches in model.go/grid.go files (only in store.go itself where the concrete struct is defined)
4. `grep -r 'store\.TodoStore' internal/` returns matches in all 5 consumer files
5. App launches and renders calendar + todo list correctly
</verification>

<success_criteria>
- TodoStore interface defined with all 15 methods matching the current Store method set
- Compile-time check `var _ TodoStore = (*Store)(nil)` in store.go
- All consumer structs use `store.TodoStore` field type
- All consumer constructors accept `store.TodoStore` parameter type
- `go build ./...` and `go vet ./...` pass
- App behavior is identical (zero functional change)
</success_criteria>

<output>
After completion, create `.planning/phases/14-database-backend/14-01-SUMMARY.md`
</output>

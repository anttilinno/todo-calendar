---
phase: 14-database-backend
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - internal/store/sqlite.go
  - internal/config/paths.go
  - main.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "Todos are stored in and loaded from a SQLite database file at ~/.config/todo-calendar/todos.db"
    - "Schema is created automatically on first run with PRAGMA user_version tracking"
    - "All existing operations (add, complete, delete, edit, reorder, search, filter) behave identically to the JSON backend"
    - "Body column exists in schema (empty default) ready for Phase 15"
    - "Save() is a no-op on the SQLite store"
  artifacts:
    - path: "internal/store/sqlite.go"
      provides: "SQLiteStore implementing TodoStore interface"
      contains: "type SQLiteStore struct"
    - path: "internal/config/paths.go"
      provides: "DBPath function for SQLite file location"
      contains: "func DBPath"
    - path: "main.go"
      provides: "App initialization using SQLite store"
      contains: "store.NewSQLiteStore"
    - path: "go.mod"
      provides: "modernc.org/sqlite dependency"
      contains: "modernc.org/sqlite"
  key_links:
    - from: "internal/store/sqlite.go"
      to: "store.TodoStore"
      via: "SQLiteStore implements TodoStore"
      pattern: "var _ TodoStore = \\(\\*SQLiteStore\\)\\(nil\\)"
    - from: "main.go"
      to: "internal/store/sqlite.go"
      via: "NewSQLiteStore constructor call"
      pattern: "store\\.NewSQLiteStore"
    - from: "internal/config/paths.go"
      to: "main.go"
      via: "DBPath provides database file path"
      pattern: "config\\.DBPath"
---

<objective>
Implement a SQLite-backed store that satisfies the TodoStore interface and wire it into the application as the default persistence backend.

Purpose: Replace the JSON file backend with SQLite for reliable ACID persistence, indexed queries, and schema evolution support. This fulfills DB-01 (SQLite storage), DB-03 (schema versioning via PRAGMA user_version), DB-04 (hand-written type-safe SQL queries per research recommendation over sqlc), and DB-05 (identical CRUD behavior).

Output: SQLiteStore implementation, DBPath helper, main.go wired to use SQLite, modernc.org/sqlite dependency added.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-database-backend/14-01-SUMMARY.md
@.planning/research/ARCHITECTURE.md
@internal/store/store.go
@internal/store/todo.go
@internal/config/paths.go
@main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add modernc.org/sqlite dependency and create SQLiteStore implementation</name>
  <files>
    internal/store/sqlite.go
    internal/config/paths.go
    go.mod
    go.sum
  </files>
  <action>
**Step 1: Add dependency.**

Run `go get modernc.org/sqlite` to add the pure-Go SQLite driver.

**Step 2: Add DBPath() to config/paths.go.**

Add a `DBPath()` function that returns the path `~/.config/todo-calendar/todos.db`:

```go
// DBPath returns the XDG-compliant path for the SQLite database file.
func DBPath() (string, error) {
    dir, err := os.UserConfigDir()
    if err != nil {
        return "", err
    }
    return filepath.Join(dir, "todo-calendar", "todos.db"), nil
}
```

Make sure `os` and `path/filepath` are imported (they likely already are in paths.go).

**Step 3: Create internal/store/sqlite.go.**

Create a new file `internal/store/sqlite.go` with the full SQLiteStore implementation. Key design points:

1. **Struct:**
```go
type SQLiteStore struct {
    db *sql.DB
}
```

2. **Constructor: `NewSQLiteStore(dbPath string) (*SQLiteStore, error)`**
   - `os.MkdirAll` on the parent directory of dbPath
   - Open with DSN: `file:<path>?_pragma=journal_mode(WAL)&_pragma=busy_timeout(5000)&_pragma=foreign_keys(ON)`
   - Driver name: `"sqlite"`
   - Set `db.SetMaxOpenConns(1)`, `db.SetMaxIdleConns(1)`, `db.SetConnMaxLifetime(0)`
   - Call `db.Ping()` to verify connection
   - Call `s.migrate()` to create/upgrade schema
   - Return the store

3. **Schema migration via PRAGMA user_version:**
```go
func (s *SQLiteStore) migrate() error {
    var version int
    err := s.db.QueryRow("PRAGMA user_version").Scan(&version)
    if err != nil {
        return err
    }
    if version < 1 {
        _, err = s.db.Exec(`
            CREATE TABLE IF NOT EXISTS todos (
                id         INTEGER PRIMARY KEY AUTOINCREMENT,
                text       TEXT    NOT NULL,
                body       TEXT    NOT NULL DEFAULT '',
                date       TEXT,
                done       INTEGER NOT NULL DEFAULT 0,
                created_at TEXT    NOT NULL,
                sort_order INTEGER NOT NULL DEFAULT 0
            );
            CREATE INDEX IF NOT EXISTS idx_todos_date ON todos(date);
            CREATE INDEX IF NOT EXISTS idx_todos_done ON todos(done);
            PRAGMA user_version = 1;
        `)
        if err != nil {
            return err
        }
    }
    return nil
}
```

   Note: `date` is nullable TEXT. NULL means floating (no date). Empty string from the old JSON model maps to NULL in SQLite.

4. **Compile-time interface check:**
```go
var _ TodoStore = (*SQLiteStore)(nil)
```

5. **Implement ALL TodoStore methods.** Critical behavioral notes for each:

   **`Add(text, date string) Todo`**: INSERT with `date` = NULL if empty string. Use `result.LastInsertId()` to get the generated ID. Compute `sort_order` as `SELECT COALESCE(MAX(sort_order), 0) + 10 FROM todos`. Return the constructed Todo with the new ID. Note: the returned Todo should have `Date: ""` (empty string) if the SQL value is NULL, to match the existing API contract.

   **`Toggle(id int)`**: `UPDATE todos SET done = NOT done WHERE id = ?`

   **`Delete(id int)`**: `DELETE FROM todos WHERE id = ?`

   **`Find(id int) *Todo`**: `SELECT id, text, date, done, created_at, sort_order FROM todos WHERE id = ?`. Use `sql.NullString` for the `date` column. Return nil if `sql.ErrNoRows`.

   **`Update(id int, text, date string)`**: `UPDATE todos SET text = ?, date = ? WHERE id = ?`. Pass NULL for date if empty string.

   **`Todos() []Todo`**: `SELECT id, text, date, done, created_at, sort_order FROM todos ORDER BY sort_order, id`

   **`TodosForMonth(year int, month time.Month) []Todo`**: Compute first and last day of the month as strings. `SELECT ... FROM todos WHERE date >= ? AND date <= ? ORDER BY sort_order, date, id`. Date range: `YYYY-MM-01` to `YYYY-MM-{lastDay}`.

   **`FloatingTodos() []Todo`**: `SELECT ... FROM todos WHERE date IS NULL ORDER BY sort_order, id`

   **`IncompleteTodosPerDay(year int, month time.Month) map[int]int`**: `SELECT CAST(substr(date, 9, 2) AS INTEGER) as day, COUNT(*) FROM todos WHERE done = 0 AND date >= ? AND date <= ? GROUP BY day`. Parse the day substring to get the day-of-month.

   **`TodoCountsByMonth() []MonthCount`**: `SELECT substr(date, 1, 7) as ym, SUM(CASE WHEN done = 0 THEN 1 ELSE 0 END) as pending, SUM(CASE WHEN done = 1 THEN 1 ELSE 0 END) as completed FROM todos WHERE date IS NOT NULL GROUP BY ym ORDER BY ym`. Parse `ym` as `YYYY-MM` to extract year and month.

   **`FloatingTodoCounts() FloatingCount`**: `SELECT SUM(CASE WHEN done = 0 THEN 1 ELSE 0 END), SUM(CASE WHEN done = 1 THEN 1 ELSE 0 END) FROM todos WHERE date IS NULL`. Handle NULL results from empty tables (use `sql.NullInt64`).

   **`SwapOrder(id1, id2 int)`**: Read sort_order for both IDs, then UPDATE both in a transaction. Use `BEGIN`/`COMMIT` explicitly or `db.Begin()`.

   **`SearchTodos(query string) []Todo`**: If query is empty, return nil. `SELECT ... FROM todos WHERE LOWER(text) LIKE ? ORDER BY CASE WHEN date IS NOT NULL THEN 0 ELSE 1 END, date, id`. Use `%` + strings.ToLower(query) + `%` as the parameter.

   **`EnsureSortOrder()`**: `UPDATE todos SET sort_order = id * 10 WHERE sort_order = 0`. This handles legacy data in a single statement. For SQLite, this is a one-shot fix.

   **`Save() error`**: Return nil (no-op). SQLite mutations auto-commit.

6. **Helper function for scanning Todo rows:**
```go
func scanTodo(scanner interface{ Scan(...any) error }) (Todo, error) {
    var t Todo
    var date sql.NullString
    var done int
    err := scanner.Scan(&t.ID, &t.Text, &date, &done, &t.CreatedAt, &t.SortOrder)
    if err != nil {
        return Todo{}, err
    }
    if date.Valid {
        t.Date = date.String
    }
    t.Done = done != 0
    return t, nil
}
```

   Use this consistently in all SELECT methods to avoid NULL handling duplication.

**Important: Do NOT include `body` in query SELECTs for now.** The body column exists in the schema but the Todo struct does not have a Body field yet (that is Phase 15). Only select the 6 fields that the current Todo struct has: id, text, date, done, created_at, sort_order.

**Import block for sqlite.go:**
```go
import (
    "database/sql"
    "fmt"
    "os"
    "path/filepath"
    "sort"
    "strings"
    "time"

    _ "modernc.org/sqlite"
)
```
  </action>
  <verify>
Run `go build ./...` -- must compile. The compile-time check `var _ TodoStore = (*SQLiteStore)(nil)` ensures all interface methods are implemented. Run `go vet ./...` for correctness.
  </verify>
  <done>SQLiteStore struct exists in internal/store/sqlite.go implementing all 15 TodoStore methods. DBPath() exists in config/paths.go. modernc.org/sqlite is in go.mod. Code compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Wire SQLite store into main.go and verify end-to-end</name>
  <files>main.go</files>
  <action>
Update main.go to use the SQLite store instead of the JSON store:

1. **Replace the JSON store initialization block** (lines ~28-38) with SQLite initialization:

```go
dbPath, err := config.DBPath()
if err != nil {
    fmt.Fprintf(os.Stderr, "Database path error: %v\n", err)
    os.Exit(1)
}

s, err := store.NewSQLiteStore(dbPath)
if err != nil {
    fmt.Fprintf(os.Stderr, "Store error: %v\n", err)
    os.Exit(1)
}
```

2. **Remove** the `store.TodosPath()` call and related JSON path logic. The `store.TodosPath()` function can remain in store.go for now (removing it is cleanup, not functional).

3. **Keep everything else the same.** The variable `s` is now `*store.SQLiteStore` which satisfies `store.TodoStore`. All downstream constructors (`app.New`, `calendar.New`, `todolist.New`, `search.New`) accept `store.TodoStore`, so this works without any other changes.

4. **Import check:** `config` package should already be imported. No new imports needed in main.go. The `store` import stays the same.
  </action>
  <verify>
1. `go build ./...` compiles without errors
2. `go vet ./...` passes
3. Run the app: `go run .` -- it should start, display the calendar and empty todo list
4. Verify the database file was created: `ls -la ~/.config/todo-calendar/todos.db`
5. Verify schema: `sqlite3 ~/.config/todo-calendar/todos.db ".schema"` should show the todos table with all columns including body
6. Verify PRAGMA: `sqlite3 ~/.config/todo-calendar/todos.db "PRAGMA user_version"` should return 1
7. Functional test: add a todo, toggle it, delete it, add a dated todo, search for it -- all should work identically to the JSON backend
  </verify>
  <done>main.go uses SQLiteStore. App starts and creates todos.db. All CRUD operations work. Schema has body column ready for Phase 15. PRAGMA user_version is 1.</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go vet ./...` passes
3. `grep -r 'NewSQLiteStore' main.go` confirms SQLite wiring
4. `grep -r 'TodoStore' internal/store/sqlite.go` confirms interface satisfaction
5. Database file exists at `~/.config/todo-calendar/todos.db` after first run
6. `sqlite3 ~/.config/todo-calendar/todos.db "PRAGMA user_version"` returns 1
7. `sqlite3 ~/.config/todo-calendar/todos.db ".schema todos"` shows all 7 columns (id, text, body, date, done, created_at, sort_order)
8. Add/toggle/delete/edit/reorder/search/filter all work in the TUI
</verification>

<success_criteria>
- SQLiteStore implements all 15 TodoStore methods
- modernc.org/sqlite is the only new dependency (pure Go, no CGo)
- Schema created automatically on first run via PRAGMA user_version
- Body column exists in schema with empty default (ready for Phase 15)
- main.go uses NewSQLiteStore instead of NewStore
- All existing TUI operations behave identically to the JSON backend
- Save() is a no-op on SQLiteStore
- WAL mode, busy_timeout, and foreign_keys pragmas are set via DSN
</success_criteria>

<output>
After completion, create `.planning/phases/14-database-backend/14-02-SUMMARY.md`
</output>

---
phase: 15-markdown-templates
plan: 03
type: execute
wave: 3
depends_on: ["15-01", "15-02"]
files_modified:
  - internal/todolist/model.go
  - internal/todolist/keys.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "User can press 't' to enter template selection mode showing a list of saved templates"
    - "User can create a new template by pressing 'T' (enters name, then content)"
    - "When creating a todo from a template, user is prompted for each placeholder value sequentially"
    - "After all placeholders are filled, a todo is created with the rendered template body"
    - "If template has no placeholders, todo is created immediately with the template body"
    - "Esc cancels at any point and returns to normal mode"
  artifacts:
    - path: "internal/todolist/model.go"
      provides: "Template selection mode, placeholder input mode, template creation mode"
      contains: "templateSelectMode"
    - path: "internal/todolist/keys.go"
      provides: "Template keybindings (TemplateUse, TemplateCreate)"
      contains: "TemplateUse"
  key_links:
    - from: "internal/todolist/model.go"
      to: "internal/tmpl/tmpl.go"
      via: "ExtractPlaceholders and ExecuteTemplate calls"
      pattern: "tmpl\\.ExtractPlaceholders"
    - from: "internal/todolist/model.go"
      to: "internal/store/store.go"
      via: "ListTemplates, AddTemplate, Add, UpdateBody calls"
      pattern: "m\\.store\\.(ListTemplates|AddTemplate|Add|UpdateBody)"
---

<objective>
Implement the template creation and usage flow in the todolist. Users can create named markdown templates and use them to create todos with rich bodies, with interactive placeholder prompting.

Purpose: Implements MDTPL-02 (create reusable templates) and MDTPL-03 (fill placeholders interactively). This completes the template workflow that connects the store layer (15-01) with the UI.
Output: New todolist modes for template management and placeholder input, wired to store template methods.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-markdown-templates/15-RESEARCH.md
@.planning/phases/15-markdown-templates/15-01-SUMMARY.md
@.planning/phases/15-markdown-templates/15-02-SUMMARY.md
@internal/todolist/model.go
@internal/todolist/keys.go
@internal/tmpl/tmpl.go
@internal/store/store.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add template keybindings and new modes to todolist</name>
  <files>internal/todolist/keys.go, internal/todolist/model.go</files>
  <action>
1. In `internal/todolist/keys.go`:
   - Add two new bindings to `KeyMap`: `TemplateUse key.Binding` and `TemplateCreate key.Binding`.
   - In `DefaultKeyMap()`:
     - `TemplateUse: key.NewBinding(key.WithKeys("t"), key.WithHelp("t", "from template"))` -- use a template to create a todo.
     - `TemplateCreate: key.NewBinding(key.WithKeys("T"), key.WithHelp("T", "new template"))` -- create a new template.
   - Add both to `ShortHelp()` and `FullHelp()`.

2. In `internal/todolist/model.go`:
   - Import `"github.com/antti/todo-calendar/internal/tmpl"` and `"github.com/charmbracelet/bubbles/textarea"`.
   - Run `go get github.com/charmbracelet/bubbles` if textarea is not already available (it should be, since bubbles is already a dependency).
   - Add new modes to the `mode` enum (after `filterMode`):
     - `templateSelectMode` -- browsing/selecting a template
     - `placeholderInputMode` -- filling in placeholder values one at a time
     - `templateNameMode` -- entering a name for a new template
     - `templateContentMode` -- entering content for a new template (multi-line)
   - Add new fields to `Model`:
     - `templates []store.Template` -- cached template list for selection
     - `templateCursor int` -- selection cursor in template list
     - `pendingTemplate *store.Template` -- selected template during placeholder flow
     - `placeholderNames []string` -- extracted placeholder names from template
     - `placeholderIndex int` -- which placeholder we're currently prompting for
     - `placeholderValues map[string]string` -- collected values so far
     - `pendingTemplateName string` -- name for template being created
     - `templateTextarea textarea.Model` -- multi-line textarea for template content entry
   - Initialize `templateTextarea` in the `New()` constructor: `ta := textarea.New()`, `ta.Placeholder = "Template content (use {{.VarName}} for placeholders)"`, `ta.ShowLineNumbers = false`. Store as field.
   - Add `TemplateUse` and `TemplateCreate` to `HelpBindings()` return in normalMode.
  </action>
  <verify>Run `go build ./...` -- compiles with new modes and fields.</verify>
  <done>New keybindings and mode enum values exist. Model has all fields needed for template workflows.</done>
</task>

<task type="auto">
  <name>Task 2: Implement template selection, placeholder input, and template creation flows</name>
  <files>internal/todolist/model.go</files>
  <action>
1. In `updateNormalMode()`, add two new key match cases:

   **TemplateUse ('t'):**
   - Load templates: `m.templates = m.store.ListTemplates()`.
   - If no templates exist, do nothing (or could show a brief message -- for simplicity, just return).
   - Set `m.templateCursor = 0`, `m.mode = templateSelectMode`.
   - Return without focusing the input (template selection uses cursor, not text input).

   **TemplateCreate ('T'):**
   - Set `m.mode = templateNameMode`.
   - Configure input: `m.input.Placeholder = "Template name"`, `m.input.Prompt = "> "`, `m.input.SetValue("")`.
   - Return with `m.input.Focus()`.

2. Add `updateTemplateSelectMode(msg tea.KeyMsg) (Model, tea.Cmd)`:
   - On Up/k: decrement `m.templateCursor`, clamp to 0.
   - On Down/j: increment `m.templateCursor`, clamp to `len(m.templates)-1`.
   - On Enter: select the template at `m.templateCursor`.
     - Set `m.pendingTemplate = &m.templates[m.templateCursor]`.
     - Extract placeholders: `names, err := tmpl.ExtractPlaceholders(m.pendingTemplate.Content)`.
     - If err or len(names) == 0: no placeholders, so go directly to todo creation:
       - Execute template with empty map: `body, _ := tmpl.ExecuteTemplate(m.pendingTemplate.Content, map[string]string{})`.
       - Enter `inputMode` to get the todo text: set `m.input.Placeholder = "Todo text for template"`, `m.input.Prompt = "> "`, `m.input.SetValue("")`.
       - But wait -- we need to associate the body with the todo. Store the body temporarily. Add a `pendingBody string` field to Model. Set `m.pendingBody = body`.
       - Actually, simplify: after template selection, always ask for todo text first (inputMode with addingDated=false), then create the todo with body. We need a way to distinguish "normal add" from "template add". Add a `fromTemplate bool` field to Model.
       - Set `m.fromTemplate = true`, `m.pendingBody = body`.
       - Enter inputMode: `m.mode = inputMode`, configure input for "What needs doing?", focus.
     - If placeholders exist:
       - Set `m.placeholderNames = names`, `m.placeholderIndex = 0`, `m.placeholderValues = make(map[string]string)`.
       - Enter `placeholderInputMode`.
       - Configure input: `m.input.Placeholder = names[0]`, `m.input.Prompt = names[0] + ": "`, `m.input.SetValue("")`.
       - Return with `m.input.Focus()`.
   - On Esc: return to normalMode. Clear template state.
   - On 'd': delete template at cursor. `m.store.DeleteTemplate(m.templates[m.templateCursor].ID)`. Reload templates. If empty, return to normalMode.

3. Add `updatePlaceholderInputMode(msg tea.KeyMsg) (Model, tea.Cmd)`:
   - On Enter:
     - Store value: `m.placeholderValues[m.placeholderNames[m.placeholderIndex]] = strings.TrimSpace(m.input.Value())`.
     - Advance: `m.placeholderIndex++`.
     - If more placeholders remain: update input prompt to next placeholder name, clear value, stay in mode.
     - If all placeholders filled:
       - Execute template: `body, err := tmpl.ExecuteTemplate(m.pendingTemplate.Content, m.placeholderValues)`.
       - Set `m.pendingBody = body`, `m.fromTemplate = true`.
       - Enter inputMode for todo text: configure input for "What needs doing?", focus.
   - On Esc: cancel, return to normalMode, clear all template state.
   - Otherwise: forward to text input.

4. Add `updateTemplateNameMode(msg tea.KeyMsg) (Model, tea.Cmd)`:
   - On Enter:
     - `name := strings.TrimSpace(m.input.Value())`. If empty, stay.
     - Save name: `m.pendingTemplateName = name`.
     - Switch to `templateContentMode`.
     - Focus the textarea: `m.templateTextarea.Reset()`, return with `m.templateTextarea.Focus()`.
   - On Esc: cancel, return to normalMode.
   - Otherwise: forward to text input.

5. Add `updateTemplateContentMode(msg tea.Msg) (Model, tea.Cmd)`:
   - Note: This mode uses `textarea.Model` (multi-line), not `textinput.Model` (single-line), since template content is markdown which is inherently multi-line.
   - On `tea.KeyMsg`:
     - On Ctrl+D (key.Matches with key.NewBinding(key.WithKeys("ctrl+d"))):
       - `content := strings.TrimSpace(m.templateTextarea.Value())`. If empty, stay.
       - Call `m.store.AddTemplate(m.pendingTemplateName, content)`.
       - Return to normalMode. Clear textarea and template state. `m.templateTextarea.Reset()`.
     - On Esc: cancel, return to normalMode. `m.templateTextarea.Reset()`.
     - Otherwise: forward msg to `m.templateTextarea.Update(msg)` (this handles Enter as newline, cursor movement, etc.).
   - All other msg types: forward to `m.templateTextarea.Update(msg)` (handles blink, etc.).

6. Modify `updateInputMode()` to handle the `fromTemplate` case:
   - In the Enter handler, after getting the text:
     - If `m.fromTemplate`:
       - If `m.addingDated`: save text to pendingText, move to dateInputMode (same as before). The body will be set after date is confirmed.
       - If not `m.addingDated`: `todo := m.store.Add(text, "")`, then `m.store.UpdateBody(todo.ID, m.pendingBody)`. Clear template state. Return to normalMode.
     - Existing non-template flow stays unchanged.

7. Similarly modify `updateDateInputMode()`:
   - After successfully adding the dated todo, if `m.fromTemplate`:
     - `m.store.UpdateBody(todo.ID, m.pendingBody)`.
     - Clear template state.

8. Add a helper method `clearTemplateState()` that resets: `m.fromTemplate = false`, `m.pendingBody = ""`, `m.pendingTemplate = nil`, `m.placeholderNames = nil`, `m.placeholderIndex = 0`, `m.placeholderValues = nil`, `m.pendingTemplateName = ""`, `m.templates = nil`, `m.templateCursor = 0`.

9. In `Update()`, add routing for the new modes:
   - For `templateContentMode`: route ALL msg types (not just KeyMsg) to `m.updateTemplateContentMode(msg)` since textarea needs tick/blink messages.
   - For `templateSelectMode`, `placeholderInputMode`, `templateNameMode`: route KeyMsg as usual.

10. In `View()`, add rendering for new modes:
    - `templateSelectMode`: Show a header "Select Template:" styled like section headers. List templates with cursor indicator ("> " for selected, "  " for others). Show template name and a truncated preview of content. Show hint: "enter select | d delete | esc cancel".
    - `templateContentMode`: Show a header "Template Content:" with the template name. Render `m.templateTextarea.View()`. Show hint: "Ctrl+D save | Esc cancel".
    - `templateNameMode`: Show "New Template:" header with the text input.
    - `placeholderInputMode`: Show "Fill placeholder:" header with current placeholder name and text input.

11. Add the new fields to Model: `pendingBody string`, `fromTemplate bool`, `pendingTemplateName string`.
  </action>
  <verify>Run `go build ./...` -- full project compiles. Code review: trace the flow from 't' press -> template select -> placeholder prompts -> todo creation with body.</verify>
  <done>User can press 't' to browse templates and select one. Placeholders are prompted sequentially. Todo is created with filled template body. User can press 'T' to create a new template (name + content). Template deletion works with 'd' in selection mode. All flows cancellable with Esc.</done>
</task>

</tasks>

<verification>
1. `go build ./...` passes with zero errors
2. `go vet ./...` passes
3. Template selection mode shows list of templates from store
4. Placeholder input mode prompts for each {{.Variable}} in order
5. After all prompts, todo is created with Add() + UpdateBody()
6. Template creation flow (T -> name -> content) calls AddTemplate
7. Esc cancels at any point and returns to normalMode cleanly
8. fromTemplate flag correctly triggers UpdateBody after Add in both dated and undated flows
9. templateContentMode uses textarea.Model for multi-line input, submits on Ctrl+D
</verification>

<success_criteria>
- Pressing 't' in normalMode enters template selection (or does nothing if no templates)
- Pressing 'T' starts template creation flow (name then content)
- Selecting a template with placeholders prompts for each value
- Selecting a template without placeholders skips to todo text input
- Created todo has the rendered template body (verified via preview 'p')
- Template deletion ('d' in select mode) removes template from store
- Full project compiles: `go build ./...`
</success_criteria>

<output>
After completion, create `.planning/phases/15-markdown-templates/15-03-SUMMARY.md`
</output>

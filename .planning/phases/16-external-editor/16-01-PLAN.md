---
phase: 16-external-editor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/editor/editor.go
  - internal/todolist/keys.go
  - internal/todolist/model.go
  - internal/app/model.go
autonomous: true

must_haves:
  truths:
    - "User presses 'o' on a selected todo and their configured editor opens with the todo body"
    - "App checks $VISUAL, then $EDITOR, then falls back to vi"
    - "Editor opens a temp file with .md extension so syntax highlighting works"
    - "If user exits editor without changing content, the todo body is not updated"
    - "TUI does not leak garbled output to terminal scrollback when editor launches"
    - "After editor save, the body indicator [+] appears on the todo if body was empty before"
  artifacts:
    - path: "internal/editor/editor.go"
      provides: "Editor resolution, temp file management, ExecProcess command, EditorFinishedMsg"
      exports: ["Open", "EditorFinishedMsg", "ResolveEditor"]
    - path: "internal/todolist/keys.go"
      provides: "OpenEditor keybinding (o)"
      contains: "OpenEditor"
    - path: "internal/todolist/model.go"
      provides: "OpenEditorMsg emission on 'o' keypress"
      contains: "OpenEditorMsg"
    - path: "internal/app/model.go"
      provides: "Editor lifecycle orchestration with editing flag"
      contains: "editing"
  key_links:
    - from: "internal/todolist/model.go"
      to: "internal/app/model.go"
      via: "OpenEditorMsg command emission"
      pattern: "OpenEditorMsg"
    - from: "internal/app/model.go"
      to: "internal/editor/editor.go"
      via: "editor.Open() call returning tea.ExecProcess"
      pattern: "editor\\.Open"
    - from: "internal/app/model.go"
      to: "internal/store"
      via: "store.UpdateBody() on content change"
      pattern: "store\\.UpdateBody|m\\.store\\.UpdateBody"
    - from: "internal/app/model.go"
      to: "View() empty string guard"
      via: "editing bool flag"
      pattern: "m\\.editing"
---

<objective>
Implement external editor integration so users can edit todo markdown bodies in their preferred terminal editor.

Purpose: This is the final feature of v1.4, connecting the markdown body infrastructure (Phase 15) to a real editing workflow. Users press 'o' on any todo to open its body in $VISUAL/$EDITOR/vi, edit markdown with full syntax highlighting, and save back to the app.

Output: New `internal/editor/` package + wiring in todolist and app models. Complete editor lifecycle: key press -> temp file -> editor launch -> content diff -> conditional save -> TUI resume.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/app/model.go
@internal/app/keys.go
@internal/todolist/model.go
@internal/todolist/keys.go
@internal/store/store.go
@internal/store/todo.go
@main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create editor package with editor resolution, temp file management, and ExecProcess integration</name>
  <files>internal/editor/editor.go</files>
  <action>
Create `internal/editor/editor.go` with the following components:

**ResolveEditor() string:**
- Check `$VISUAL` first, then `$EDITOR`, then fall back to `"vi"` (POSIX fallback, not vim). This order follows EDITOR-02 requirement exactly.
- Return the raw string (splitting happens in Open).

**EditorFinishedMsg struct:**
- Fields: `TodoID int`, `TempPath string`, `OriginalBody string`, `Err error`
- This message is returned by the ExecProcess callback to app.Model.

**Open(todoID int, title string, body string) tea.Cmd:**
1. Write a temp file using `os.CreateTemp("", "todo-calendar-*.md")` -- the `.md` extension is critical for editor syntax highlighting (EDITOR-03).
2. File content format: `# {title}\n\n{body}` -- the `# heading` line is the todo title, everything after is the body. If body is empty, just write `# {title}\n\n` so the user has a starting point.
3. Resolve editor string via ResolveEditor().
4. Split the editor string on whitespace using `strings.Fields()` to handle cases like `EDITOR="code --wait"` or `EDITOR="nvim -u NONE"`. First token is the executable, remaining tokens are prepended args before the temp file path.
5. Construct `exec.Command(parts[0], append(parts[1:], tempPath)...)`.
6. Store the original body content for later comparison.
7. Return `tea.ExecProcess(cmd, func(err error) tea.Msg { return EditorFinishedMsg{...} })`.

**ReadResult(msg EditorFinishedMsg) (newBody string, changed bool, err error):**
1. If `msg.Err != nil`, return error (editor failed).
2. Read the temp file content from `msg.TempPath`.
3. Parse: find first line matching `^# (.+)$` -- that's the title (we ignore title changes for now, only body matters). Everything after the first heading line, trimmed of leading/trailing whitespace, is the new body.
4. Compare new body to `msg.OriginalBody`. If identical, return `changed = false` (EDITOR-04).
5. Return the new body and `changed = true`.
6. Caller is responsible for `os.Remove(msg.TempPath)` after processing.

**parseBody(content string) string:**
- Internal helper. Split content by lines. Skip the first line that starts with `# `. Join remaining lines. Trim leading blank lines and trailing whitespace.
- If no `# ` heading found, treat entire content as body.

Import `os`, `os/exec`, `strings`, and `tea "github.com/charmbracelet/bubbletea"`.
  </action>
  <verify>
`cd /home/antti/Repos/Misc/todo-calendar && go build ./internal/editor/` compiles without errors.
  </verify>
  <done>
editor.go exists with ResolveEditor ($VISUAL -> $EDITOR -> vi), Open (temp .md file + ExecProcess), ReadResult (content comparison), and EditorFinishedMsg type. Package compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire editor into todolist keybinding and app model lifecycle</name>
  <files>internal/todolist/keys.go, internal/todolist/model.go, internal/app/model.go</files>
  <action>
**internal/todolist/keys.go:**
1. Add `OpenEditor key.Binding` field to KeyMap struct.
2. Add to DefaultKeyMap: `OpenEditor: key.NewBinding(key.WithKeys("o"), key.WithHelp("o", "open editor"))`.
3. Add `k.OpenEditor` to ShortHelp, FullHelp return slices.

**internal/todolist/model.go:**
1. Add `OpenEditorMsg` type: `type OpenEditorMsg struct { Todo store.Todo }` (similar to PreviewMsg pattern).
2. In `updateNormalMode`, add a case for `key.Matches(msg, m.keys.OpenEditor)`: when a todo is selected, emit `OpenEditorMsg` via a command function (same pattern as PreviewMsg on line 376-380). The todo must be fetched fresh from store via `m.store.Find(todo.ID)` to get the current body content. If no todo is selected, do nothing.
3. Add `m.keys.OpenEditor` to the HelpBindings() return in normalMode (add it after Preview, before TemplateUse in the bindings list).

**internal/app/model.go:**
1. Add `editing bool` field to Model struct. This is the critical alt-screen workaround (Pitfall #4).
2. In `View()`, add as the VERY FIRST check (before `!m.ready`): `if m.editing { return "" }`. This prevents Bubble Tea from leaking TUI content to terminal scrollback during editor launch.
3. Add import for `"github.com/antti/todo-calendar/internal/editor"`.
4. In `Update()`, add two new message handlers in the type switch at the top (alongside settings.SaveMsg, search.JumpMsg, etc.):

   **case todolist.OpenEditorMsg:**
   - Set `m.editing = true`.
   - Get the todo from the message: `todo := msg.Todo`.
   - Return `m, editor.Open(todo.ID, todo.Text, todo.Body)`.

   **case editor.EditorFinishedMsg:**
   - Set `m.editing = false` immediately (restore rendering).
   - Call `editor.ReadResult(msg)` to get newBody, changed, err.
   - Clean up temp file immediately after reading: `os.Remove(msg.TempPath)` (always, regardless of error â€” prevent /tmp accumulation).
   - If err != nil, just return (silently ignore editor errors -- no data corruption).
   - If changed, call `m.store.UpdateBody(msg.TodoID, newBody)`.
   - Call `m.calendar.RefreshIndicators()` to update bracket indicators if body status changed.
   - Return m, nil.

5. The `editing` flag check in View() MUST be before the `!m.ready` check. During editor execution, Bubble Tea calls View() one final time during alt-screen teardown. If View() returns content, it leaks to the normal terminal buffer.
  </action>
  <verify>
`cd /home/antti/Repos/Misc/todo-calendar && go build ./...` compiles without errors. Run the app with `go run .` and verify: focus todo pane (Tab), navigate to a todo, press 'o' -- editor opens. Type some markdown, save and quit editor -- body is saved (verify with 'p' to preview). Press 'o' again, quit without changing -- body should NOT be re-saved (verify no extra writes by checking the preview still shows same content).
  </verify>
  <done>
'o' key on a selected todo opens $VISUAL/$EDITOR/vi with the todo body in a .md temp file. Editing and saving updates the body. Quitting without changes does not update. TUI resumes cleanly with no terminal artifacts. Help bar shows 'o open editor' when todo pane is focused.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` -- entire project compiles
2. `go vet ./...` -- no vet issues
3. Press 'o' on a todo with no body -- editor opens with `# {title}` heading and empty body area
4. Type markdown content, save, exit editor -- body is saved, `[+]` indicator appears
5. Press 'p' to preview -- rendered markdown shows the content just entered
6. Press 'o' again, exit without changes -- body is NOT updated (EDITOR-04)
7. Set `VISUAL=nano` and press 'o' -- nano opens (EDITOR-02 fallback chain)
8. No garbled TUI output in terminal scrollback after editor closes (Pitfall #4 mitigated)
9. Help bar shows 'o open editor' alongside other todo keybindings
</verification>

<success_criteria>
- EDITOR-01: 'o' key opens selected todo body in external editor
- EDITOR-02: $VISUAL -> $EDITOR -> vi fallback chain works
- EDITOR-03: Temp file has .md extension, editor shows markdown highlighting
- EDITOR-04: Body only saved when content actually changed
- No terminal artifacts from alt-screen transition
- Calendar indicators refresh after body edit
- Help bar displays the new keybinding
</success_criteria>

<output>
After completion, create `.planning/phases/16-external-editor/16-01-SUMMARY.md`
</output>

---
phase: 18-full-pane-editing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/todolist/styles.go
  - internal/todolist/keys.go
  - internal/todolist/model.go
  - internal/app/model.go
autonomous: true

must_haves:
  truths:
    - "Pressing 'a' to add a todo replaces the todo list with a centered full-pane input showing a title field"
    - "Editing a todo title (e) uses the same full-pane layout with current value pre-filled"
    - "Editing a todo date (E) uses the same full-pane layout with current value pre-filled"
    - "Full-pane edit view shows only minimal help (Enter confirm, Esc cancel)"
    - "Full-pane form is vertically centered in the right pane"
  artifacts:
    - path: "internal/todolist/styles.go"
      provides: "EditTitle, FieldLabel, EditHint styles"
      contains: "EditTitle"
    - path: "internal/todolist/keys.go"
      provides: "SwitchField key binding for Tab"
      contains: "SwitchField"
    - path: "internal/todolist/model.go"
      provides: "SetSize method, dateInput field, editField tracker, editView renderer"
      contains: "func (m Model) editView()"
    - path: "internal/app/model.go"
      provides: "SetSize call passing pane dimensions to todolist"
      contains: "SetSize"
  key_links:
    - from: "internal/app/model.go"
      to: "internal/todolist/model.go"
      via: "SetSize(todoInnerWidth, contentHeight) call"
      pattern: "todoList\\.SetSize"
    - from: "internal/todolist/model.go View()"
      to: "internal/todolist/model.go editView()"
      via: "mode-branched dispatch in View()"
      pattern: "case inputMode.*editView"
---

<objective>
Implement full-pane editing infrastructure and single-field edit views for the todolist component.

Purpose: Replace cramped inline text inputs with a clean, centered full-pane layout when adding or editing todos. This covers EDIT-01 (add todo), EDIT-03 (edit title), EDIT-04 (edit date), and EDIT-05 (minimal help). The simultaneous two-field dated-add flow (EDIT-02) is handled in plan 18-02.

Output: When users press 'a', 'e', or 'E', the todo list is replaced with a vertically centered form showing a title/field label, the text input, and minimal contextual help.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-full-pane-editing/18-RESEARCH.md
@internal/todolist/model.go
@internal/todolist/styles.go
@internal/todolist/keys.go
@internal/app/model.go
@internal/app/styles.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add edit styles, dateInput field, editField, SetSize, and Tab key binding</name>
  <files>
    internal/todolist/styles.go
    internal/todolist/keys.go
    internal/todolist/model.go
    internal/app/model.go
  </files>
  <action>
**styles.go:** Add three new styles to the Styles struct and NewStyles constructor:
- `EditTitle lipgloss.Style` — Bold, AccentFg foreground. Used for "Add Todo" / "Edit Todo" headings.
- `FieldLabel lipgloss.Style` — Bold, NormalFg foreground. Used for "Title", "Date" labels.
- `EditHint lipgloss.Style` — MutedFg foreground. Used for "Enter confirm | Esc cancel" hint text.

**keys.go:** Add `SwitchField key.Binding` to the KeyMap struct. In DefaultKeyMap(), set it to:
```go
SwitchField: key.NewBinding(
    key.WithKeys("tab"),
    key.WithHelp("tab", "switch field"),
),
```
This does NOT conflict with app-level Tab pane switching because the app already suppresses Tab when `IsInputting()` returns true.

**model.go — struct changes:** Add to the Model struct:
- `dateInput textinput.Model` — second text input for date field in full-pane mode
- `editField int` — 0 = title focused, 1 = date focused

**model.go — New() constructor:** Initialize dateInput after the existing `ti` initialization:
```go
di := textinput.New()
di.Placeholder = "YYYY-MM-DD"
di.Prompt = "Date: "
di.CharLimit = 10
```
Store `di` in the returned Model as `dateInput: di`.

**model.go — SetSize method:** Add a new exported method. The todolist model already has `width` and `height` fields but they receive raw terminal dimensions via WindowSizeMsg. This method receives actual pane dimensions from the app:
```go
func (m *Model) SetSize(w, h int) {
    m.width = w
    m.height = h
}
```

**app/model.go — call SetSize:** In the `View()` method, after computing `todoInnerWidth` and `contentHeight` (around line 432-433), add a call:
```go
m.todoList.SetSize(todoInnerWidth, contentHeight)
```
Place this BEFORE the `todoStyle.Render(m.todoList.View())` call. Note: `m` is a value receiver in View(), so we need to call it on the model before rendering. Since View() has value receiver, use a local approach: call SetSize before View() is invoked. The simplest approach is to add it right before the Render call. Since `m.todoList` is accessed by value and SetSize is a pointer receiver, this needs the app.Model to pass by pointer or use a different approach.

**Important implementation detail:** The app.View() method has a value receiver `(m Model)`. Calling `m.todoList.SetSize(...)` on a value receiver copies the model. Instead, modify the approach: call `m.todoList.SetSize(todoInnerWidth, contentHeight)` in the `tea.WindowSizeMsg` handler in `app.Model.Update()` (which has a value receiver that returns the modified model). Specifically, in the `case tea.WindowSizeMsg:` block (around line 236-249), after `m.ready = true`, add:
```go
// Compute pane dimensions for todolist full-pane editing
frameH, frameV := m.styles.Pane(true).GetFrameSize()
helpHeight := 1 // approximate; exact measured at render time
contentHeight := m.height - helpHeight - frameV
if contentHeight < 1 {
    contentHeight = 1
}
calendarInnerWidth := 38
todoInnerWidth := m.width - calendarInnerWidth - (frameH * 2)
if todoInnerWidth < 1 {
    todoInnerWidth = 10
}
m.todoList.SetSize(todoInnerWidth, contentHeight)
```
Remove the existing `m.todoList, todoCmd = m.todoList.Update(msg)` WindowSizeMsg broadcast to todolist since we now set dimensions explicitly (the todolist's own WindowSizeMsg handler would overwrite with raw terminal dimensions). Keep the calendar Update broadcast. Replace:
```go
var calCmd, todoCmd tea.Cmd
m.calendar, calCmd = m.calendar.Update(msg)
m.todoList, todoCmd = m.todoList.Update(msg)
return m, tea.Batch(calCmd, todoCmd)
```
With:
```go
var calCmd tea.Cmd
m.calendar, calCmd = m.calendar.Update(msg)
return m, calCmd
```
  </action>
  <verify>
Run `cd /home/antti/Repos/Misc/todo-calendar && go build ./...` — must compile with zero errors.
Verify that `SetSize` method exists: `grep -n "func.*SetSize" internal/todolist/model.go`
Verify styles added: `grep -n "EditTitle\|FieldLabel\|EditHint" internal/todolist/styles.go`
Verify SwitchField key: `grep -n "SwitchField" internal/todolist/keys.go`
Verify dateInput field: `grep -n "dateInput" internal/todolist/model.go | head -5`
  </verify>
  <done>
The todolist package has: EditTitle/FieldLabel/EditHint styles, SwitchField key binding, dateInput textinput.Model, editField int, and SetSize(w,h) method. The app calls SetSize with correct pane dimensions on WindowSizeMsg. Code compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor View() for mode-branched full-pane rendering</name>
  <files>
    internal/todolist/model.go
  </files>
  <action>
Refactor the `View()` method to branch on mode. When in edit modes (inputMode, dateInputMode, editTextMode, editDateMode), render a full-pane centered form instead of the todo list. Template modes and filterMode continue to render inline below the list as before.

**Step 1: Extract normal view.** Rename the current View() body into a new private method `normalView()` that returns the todo list rendering. The new View() dispatches:

```go
func (m Model) View() string {
    switch m.mode {
    case inputMode, dateInputMode, editTextMode, editDateMode:
        return m.editView()
    default:
        return m.normalView()
    }
}
```

Move the existing View() body (lines 784-868) into `normalView()` unchanged.

**Step 2: Implement editView().** Create the `editView()` method that renders a vertically centered full-pane form:

```go
func (m Model) editView() string {
    var b strings.Builder

    // Title heading
    switch {
    case m.mode == editTextMode || m.mode == editDateMode:
        b.WriteString(m.styles.EditTitle.Render("Edit Todo"))
    default:
        b.WriteString(m.styles.EditTitle.Render("Add Todo"))
    }
    b.WriteString("\n\n")

    // Determine what fields to show
    showDate := m.addingDated || m.mode == dateInputMode || m.mode == editDateMode

    if m.mode == editDateMode {
        // Edit date: single date field
        b.WriteString(m.styles.FieldLabel.Render("Date"))
        b.WriteString("\n")
        b.WriteString(m.input.View())
    } else if showDate {
        // Dated add: show both title and date fields
        // Title field
        titleLabel := "Title"
        if m.editField == 0 {
            titleLabel = "Title"  // active field indicator handled by textinput focus
        }
        b.WriteString(m.styles.FieldLabel.Render(titleLabel))
        b.WriteString("\n")
        if m.editField == 0 || m.mode == inputMode {
            b.WriteString(m.input.View())
        } else {
            // Show value without cursor when not focused
            val := m.input.Value()
            if val == "" {
                val = m.input.Placeholder
                b.WriteString(m.styles.Empty.Render("  " + val))
            } else {
                b.WriteString("  " + val)
            }
        }
        b.WriteString("\n\n")

        // Date field
        b.WriteString(m.styles.FieldLabel.Render("Date"))
        b.WriteString("\n")
        if m.mode == dateInputMode || m.editField == 1 {
            b.WriteString(m.dateInput.View())
        } else {
            val := m.dateInput.Value()
            if val == "" {
                val = m.dateInput.Placeholder
                b.WriteString(m.styles.Empty.Render("  " + val))
            } else {
                b.WriteString("  " + val)
            }
        }
    } else {
        // Single field: title only (add non-dated, edit text)
        b.WriteString(m.styles.FieldLabel.Render("Title"))
        b.WriteString("\n")
        b.WriteString(m.input.View())
    }
    b.WriteString("\n\n")

    // Minimal help hint (EDIT-05)
    hint := "Enter confirm  •  Esc cancel"
    if showDate && m.mode != editDateMode {
        hint = "Enter confirm  •  Esc cancel  •  Tab switch field"
    }
    b.WriteString(m.styles.EditHint.Render(hint))

    // Vertical centering
    content := b.String()
    contentLines := strings.Count(content, "\n") + 1
    if m.height > contentLines {
        topPad := (m.height - contentLines) / 3  // upper-third positioning
        if topPad > 0 {
            content = strings.Repeat("\n", topPad) + content
        }
    }

    return content
}
```

**Important notes on editView implementation:**
- For the simple add (non-dated, inputMode with `addingDated == false`): show only the title field with `m.input.View()`.
- For editTextMode: show only the title field with `m.input.View()` (pre-filled from updateNormalMode).
- For editDateMode: show only the date field with `m.input.View()` (pre-filled from updateNormalMode).
- For dated add (inputMode with `addingDated == true`): show both title (m.input) and date (m.dateInput) fields. In inputMode, title is focused. In dateInputMode, date is focused. This is wired in plan 18-02.
- Use `/3` instead of `/2` for topPad to position the form in the upper third rather than dead center, which feels more natural for a form.
- The hint text uses bullet separator `•` for consistency.

**Step 3: Update HelpBindings()** to include Tab hint when in dated modes with two fields:

```go
func (m Model) HelpBindings() []key.Binding {
    switch m.mode {
    case inputMode:
        if m.addingDated {
            return []key.Binding{m.keys.Confirm, m.keys.Cancel, m.keys.SwitchField}
        }
        return []key.Binding{m.keys.Confirm, m.keys.Cancel}
    case dateInputMode:
        return []key.Binding{m.keys.Confirm, m.keys.Cancel, m.keys.SwitchField}
    case editTextMode, editDateMode:
        return []key.Binding{m.keys.Confirm, m.keys.Cancel}
    case normalMode:
        return []key.Binding{m.keys.Add, m.keys.Toggle, m.keys.Delete, m.keys.Edit, m.keys.Filter}
    default:
        return []key.Binding{m.keys.Confirm, m.keys.Cancel}
    }
}
```

Also update `AllHelpBindings()` similarly -- when in non-normal modes with two-field form, include SwitchField:
```go
func (m Model) AllHelpBindings() []key.Binding {
    switch m.mode {
    case inputMode:
        if m.addingDated {
            return []key.Binding{m.keys.Confirm, m.keys.Cancel, m.keys.SwitchField}
        }
        return []key.Binding{m.keys.Confirm, m.keys.Cancel}
    case dateInputMode:
        return []key.Binding{m.keys.Confirm, m.keys.Cancel, m.keys.SwitchField}
    case editTextMode, editDateMode:
        return []key.Binding{m.keys.Confirm, m.keys.Cancel}
    case normalMode:
        // existing full binding list
        return []key.Binding{
            m.keys.Up, m.keys.Down, m.keys.MoveUp, m.keys.MoveDown,
            m.keys.Add, m.keys.AddDated, m.keys.Edit, m.keys.EditDate,
            m.keys.Toggle, m.keys.Delete, m.keys.Filter,
            m.keys.Preview, m.keys.OpenEditor, m.keys.TemplateUse, m.keys.TemplateCreate,
        }
    default:
        return []key.Binding{m.keys.Confirm, m.keys.Cancel}
    }
}
```

**Step 4: Set input width.** In editView(), before rendering fields, set the text input width based on pane width. Add at the top of editView() before building the form:
```go
inputWidth := m.width - 4  // leave some padding
if inputWidth < 20 {
    inputWidth = 20
}
m.input.Width = inputWidth
m.dateInput.Width = inputWidth
```

Note: Since View() has a value receiver, modifying m.input.Width on the copy is fine for rendering -- it won't persist, but the visual effect is correct. If this causes issues, set width in SetSize() instead (pointer receiver).
  </action>
  <verify>
Run `cd /home/antti/Repos/Misc/todo-calendar && go build ./...` — must compile cleanly.
Run `cd /home/antti/Repos/Misc/todo-calendar && go vet ./...` — no issues.
Verify editView exists: `grep -n "func.*editView\|func.*normalView" internal/todolist/model.go`
Verify mode branching in View: `grep -n "case inputMode" internal/todolist/model.go | head -3`
Run the app briefly to check it doesn't crash: `cd /home/antti/Repos/Misc/todo-calendar && timeout 2 go run . 2>/dev/null || true`
  </verify>
  <done>
View() dispatches to editView() for add/edit modes and normalView() for everything else. The editView() renders a vertically centered form with EditTitle heading, FieldLabel labels, the appropriate text input(s), and an EditHint showing minimal contextual help. Single-field modes (add non-dated, edit text, edit date) show one field. Dated-add mode shows both fields (wired fully in 18-02). HelpBindings includes Tab for two-field modes.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go vet ./...` passes
3. Pressing 'a' in the app shows a full-pane "Add Todo" form with title field, not inline input below the list
4. Pressing 'e' on a todo shows "Edit Todo" form with pre-filled title
5. Pressing 'E' on a todo shows "Edit Todo" form with pre-filled date
6. All edit forms show "Enter confirm | Esc cancel" hint
7. Enter confirms, Esc cancels in all edit modes
8. Normal mode todo list rendering is unchanged
9. Template modes (templateSelectMode etc.) continue rendering inline as before
</verification>

<success_criteria>
- Full-pane layout replaces inline input for add/edit modes
- Edit forms are vertically centered in the right pane
- EditTitle, FieldLabel, EditHint styles render with correct theme colors
- Existing add/edit functionality (Enter confirms, Esc cancels) unchanged
- Template and filter modes unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/18-full-pane-editing/18-01-SUMMARY.md`
</output>

---
phase: 18-full-pane-editing
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - internal/todolist/model.go
autonomous: true

must_haves:
  truths:
    - "Adding a dated todo (A) shows both title and date fields simultaneously in the full pane"
    - "Tab switches focus between title and date fields"
    - "Enter from either field confirms both values (title + date)"
    - "The date field shows the configured date placeholder"
    - "Help hint shows Tab for field switching during dated-add"
  artifacts:
    - path: "internal/todolist/model.go"
      provides: "Dual-field dated-add flow with Tab switching"
      contains: "SwitchField"
  key_links:
    - from: "updateInputMode (dated)"
      to: "editField toggle"
      via: "Tab key switches editField and Focus/Blur"
      pattern: "SwitchField"
    - from: "confirm handler (dated)"
      to: "m.input.Value() + m.dateInput.Value()"
      via: "reads both fields on Enter regardless of focus"
      pattern: "dateInput\\.Value"
---

<objective>
Wire the simultaneous two-field dated-add flow so pressing 'A' shows both title and date fields at once with Tab to switch between them.

Purpose: Fulfill EDIT-02 -- adding a dated todo shows both title and date fields with clear labels in the full pane. The current sequential flow (type title -> Enter -> type date) is replaced with a unified form where both fields are always visible and Tab switches focus.

Output: When users press 'A', the full-pane form shows Title and Date fields. Title is focused first. Tab moves focus to Date (and back). Enter from either field validates and creates the todo using both values.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-full-pane-editing/18-RESEARCH.md
@.planning/phases/18-full-pane-editing/18-01-SUMMARY.md
@internal/todolist/model.go
@internal/todolist/keys.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire Tab field switching and unified confirm for dated-add</name>
  <files>
    internal/todolist/model.go
  </files>
  <action>
Modify the dated-add flow to use both fields simultaneously instead of the current two-step sequential approach.

**Step 1: Update AddDated handler in updateNormalMode().** When 'A' is pressed, initialize both fields:

In the `case key.Matches(msg, m.keys.AddDated):` block, after setting `m.addingDated = true`, also:
- Reset the dateInput: `m.dateInput.SetValue("")`, set `m.dateInput.Placeholder` to `m.datePlaceholder`
- Set `m.editField = 0` (title field focused first)
- Set `m.dateInput.Prompt = "> "` (consistent prompt style)

The existing code already sets `m.mode = inputMode`, `m.input.Placeholder`, `m.input.SetValue("")`, and returns `m.input.Focus()`. This is correct -- title field is focused first.

**Step 2: Add Tab handling in updateInputMode().** Currently updateInputMode handles Confirm and Cancel. Add a new case before the fallthrough to textinput.Update:

```go
case key.Matches(msg, m.keys.SwitchField):
    if m.addingDated {
        if m.editField == 0 {
            m.editField = 1
            m.input.Blur()
            return m, m.dateInput.Focus()
        } else {
            m.editField = 0
            m.dateInput.Blur()
            return m, m.input.Focus()
        }
    }
    // Non-dated add: Tab is a no-op (ignored)
    return m, nil
```

**Step 3: Add Tab handling in dateInputMode.** The dateInputMode is still used when the sequential flow transitions (via Enter from inputMode in dated flow). However, with the new simultaneous flow, we need to reconsider this.

**New approach for dated-add confirm:** When `addingDated` is true and user presses Enter in inputMode:
- Instead of transitioning to dateInputMode, validate BOTH fields and create the todo.
- Read title from `m.input.Value()` and date from `m.dateInput.Value()`.
- Title must be non-empty. Date must be non-empty and parseable.
- If title is empty and editField == 0, stay (user hasn't typed yet).
- If date is empty and editField == 0, switch focus to date field.
- If date is empty and editField == 1, stay (user hasn't typed yet).
- If date is invalid, stay.

Modify the `case key.Matches(msg, m.keys.Confirm):` block in `updateInputMode()`:

Replace the current dated-add branch:
```go
if m.addingDated {
    m.pendingText = text
    m.mode = dateInputMode
    m.input.Placeholder = m.datePlaceholder
    m.input.Prompt = "Date: "
    m.input.SetValue("")
    return m, nil
}
```

With the new unified confirm:
```go
if m.addingDated {
    // Both fields must be valid
    title := strings.TrimSpace(m.input.Value())
    if title == "" {
        return m, nil
    }
    date := strings.TrimSpace(m.dateInput.Value())
    if date == "" {
        // Auto-switch to date field if empty
        m.editField = 1
        m.input.Blur()
        return m, m.dateInput.Focus()
    }
    isoDate, err := config.ParseUserDate(date, m.dateLayout)
    if err != nil {
        // Invalid date -- focus date field
        m.editField = 1
        m.input.Blur()
        return m, m.dateInput.Focus()
    }
    todo := m.store.Add(title, isoDate)
    if m.fromTemplate {
        m.store.UpdateBody(todo.ID, m.pendingBody)
        m.clearTemplateState()
    }
    m.mode = normalMode
    m.input.Blur()
    m.dateInput.Blur()
    m.input.SetValue("")
    m.dateInput.SetValue("")
    m.editField = 0
    return m, nil
}
```

**Step 4: Keep dateInputMode for backward compatibility.** The dateInputMode is still reachable from the template flow (when placeholders are filled and then the todo text is entered, the old flow could transition to dateInputMode). However, check if any path still leads to dateInputMode for the dated-add flow. With the above change, the normal 'A' flow no longer transitions to dateInputMode. The template flow goes: templateSelectMode -> placeholderInputMode -> inputMode (for todo text). If `addingDated` were true (which it's not in template flow -- templates always go through inputMode with `addingDated = false`), it would use the new unified flow.

Keep `updateDateInputMode()` and the dateInputMode case in the View/editView for safety, but it should now only be reachable via direct code paths if any remain. The editView() already handles dateInputMode rendering from plan 18-01.

**Step 5: Update dateInput blink/cursor forwarding.** The `dateInput` textinput needs its Update() called for cursor blink messages (tea.Msg, not just tea.KeyMsg). Currently, the todolist's main Update() only forwards tea.KeyMsg to mode handlers. The textinput cursor blink uses internal Blink messages.

Add a case in the main `Update()` method to forward non-KeyMsg messages to the focused textinput when in edit modes:

In the `Update()` function, after the `case tea.WindowSizeMsg:` handler but before the `case tea.KeyMsg:` handler, add a default message forwarder for input models when in edit modes:

Actually, looking at the code more carefully: the existing textinput for `m.input` works fine because its blink messages are handled via the tea.Cmd returned from `m.input.Focus()`. The blink cmd sends a message that goes through Update(). Currently, in Update(), non-KeyMsg non-WindowSizeMsg messages fall through and are ignored (the function returns `m, nil`).

The textinput blink messages need to reach the textinput's Update method. Add this at the beginning of the Update function, before the switch on msg type, when in edit modes:

```go
// Forward blink/tick messages to focused text input in edit modes
switch m.mode {
case inputMode, dateInputMode, editTextMode, editDateMode:
    if _, ok := msg.(tea.KeyMsg); !ok {
        if _, ok := msg.(tea.WindowSizeMsg); !ok {
            // Forward to the active input for cursor blink
            var cmd tea.Cmd
            if m.editField == 1 && (m.mode == inputMode || m.mode == dateInputMode) {
                m.dateInput, cmd = m.dateInput.Update(msg)
            } else {
                m.input, cmd = m.input.Update(msg)
            }
            return m, cmd
        }
    }
}
```

Place this right after the existing `templateContentMode` check at the top of Update().

**Step 6: Reset dateInput on cancel.** In updateInputMode's Cancel case, also reset dateInput:
```go
case key.Matches(msg, m.keys.Cancel):
    m.mode = normalMode
    m.input.Blur()
    m.input.SetValue("")
    m.dateInput.Blur()
    m.dateInput.SetValue("")
    m.editField = 0
    m.pendingText = ""
    m.clearTemplateState()
    return m, nil
```

**Step 7: Forward key events to the correct input.** At the bottom of updateInputMode(), the fallthrough sends all non-matched keys to `m.input.Update(msg)`. When `editField == 1` and `addingDated` is true, keys should go to `m.dateInput` instead:

Replace:
```go
var cmd tea.Cmd
m.input, cmd = m.input.Update(msg)
return m, cmd
```

With:
```go
var cmd tea.Cmd
if m.addingDated && m.editField == 1 {
    m.dateInput, cmd = m.dateInput.Update(msg)
} else {
    m.input, cmd = m.input.Update(msg)
}
return m, cmd
```
  </action>
  <verify>
Run `cd /home/antti/Repos/Misc/todo-calendar && go build ./...` — must compile cleanly.
Run `cd /home/antti/Repos/Misc/todo-calendar && go vet ./...` — no issues.
Verify SwitchField handling: `grep -n "SwitchField" internal/todolist/model.go`
Verify both field values read on confirm: `grep -n "dateInput.Value\|input.Value" internal/todolist/model.go | head -10`
Verify dateInput reset on cancel: `grep -A3 "Cancel.*addingDated\|dateInput.Blur\|dateInput.SetValue" internal/todolist/model.go | head -10`
Run app briefly: `cd /home/antti/Repos/Misc/todo-calendar && timeout 2 go run . 2>/dev/null || true`
  </verify>
  <done>
Pressing 'A' shows both Title and Date fields simultaneously in the full-pane view. Tab switches focus between them. Enter validates both fields and creates the dated todo. If date is empty or invalid when Enter is pressed, focus auto-switches to the date field. Esc cancels and resets both fields. The cursor blinks correctly in the focused field.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go vet ./...` passes
3. Press 'A' — full-pane form shows "Add Todo" with Title and Date fields, both visible
4. Title field is focused first (cursor visible, text input active)
5. Press Tab — focus moves to Date field (cursor moves, title shows entered text)
6. Press Tab again — focus returns to Title field
7. Type title, Tab, type date, Enter — todo is created with correct title and date
8. Press Enter with empty date — focus auto-switches to date field
9. Press Esc at any point — cancels and returns to normal todo list
10. Help hint shows "Enter confirm | Esc cancel | Tab switch field"
11. Regular add ('a') still works as single-field form (no date field shown)
12. Edit text ('e') and edit date ('E') still work as single-field forms
</verification>

<success_criteria>
- Dated-add shows both fields simultaneously (not sequential)
- Tab switches focus between title and date
- Enter reads both field values regardless of which is focused
- Empty/invalid date auto-focuses the date field with no crash
- Template flow (if it reaches dated-add) still works
- Cursor blink works in both fields
</success_criteria>

<output>
After completion, create `.planning/phases/18-full-pane-editing/18-02-SUMMARY.md`
</output>

---
phase: 20-template-management-overlay
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/store/store.go
  - internal/store/sqlite.go
  - internal/store/todo.go
  - internal/tmplmgr/model.go
  - internal/tmplmgr/keys.go
  - internal/tmplmgr/styles.go
autonomous: true

must_haves:
  truths:
    - "UpdateTemplate method exists on TodoStore interface and is implemented in SQLiteStore"
    - "tmplmgr.Model can list templates with cursor navigation"
    - "Selected template content is displayed as raw text below the template list"
    - "Pressing d deletes the selected template"
    - "Pressing r enters rename mode with pre-filled input, duplicate names show error"
    - "Pressing Esc in list mode emits CloseMsg"
  artifacts:
    - path: "internal/store/store.go"
      provides: "UpdateTemplate method on TodoStore interface"
      contains: "UpdateTemplate"
    - path: "internal/store/sqlite.go"
      provides: "UpdateTemplate SQLite implementation"
      contains: "func (s *SQLiteStore) UpdateTemplate"
    - path: "internal/tmplmgr/model.go"
      provides: "Template management overlay Model with list, preview, rename, delete"
      min_lines: 150
    - path: "internal/tmplmgr/keys.go"
      provides: "KeyMap for overlay navigation and actions"
      contains: "DefaultKeyMap"
    - path: "internal/tmplmgr/styles.go"
      provides: "Themed lipgloss styles for overlay rendering"
      contains: "NewStyles"
  key_links:
    - from: "internal/tmplmgr/model.go"
      to: "internal/store/store.go"
      via: "store.TodoStore interface"
      pattern: "store\\.TodoStore"
    - from: "internal/tmplmgr/model.go"
      to: "internal/store/todo.go"
      via: "store.Template type"
      pattern: "store\\.Template"
---

<objective>
Create the template management overlay package and extend the store interface with UpdateTemplate.

Purpose: Build the self-contained tmplmgr component that can list, preview, delete, and rename templates. This is the core overlay that Plan 02 will wire into the app.
Output: New internal/tmplmgr/ package (model.go, keys.go, styles.go) and UpdateTemplate on the store interface.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
@internal/store/store.go
@internal/store/sqlite.go
@internal/store/todo.go
@internal/search/model.go
@internal/search/keys.go
@internal/search/styles.go
@internal/theme/theme.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add UpdateTemplate to store interface and implementations</name>
  <files>internal/store/store.go, internal/store/sqlite.go</files>
  <action>
Add `UpdateTemplate(id int, name, content string) error` to the TodoStore interface in store.go. This method updates both name and content of a template by ID.

In sqlite.go, implement UpdateTemplate:
```go
func (s *SQLiteStore) UpdateTemplate(id int, name, content string) error {
    _, err := s.db.Exec("UPDATE templates SET name = ?, content = ? WHERE id = ?", name, content, id)
    if err != nil {
        return fmt.Errorf("update template: %w", err)
    }
    return nil
}
```
Note: This returns an error (unlike most existing store methods) because the UNIQUE constraint on name can fail, and the caller (rename UI) needs to handle that gracefully per Pitfall 7 in PITFALLS.md.

In store.go (the JSON Store), add a stub:
```go
func (s *Store) UpdateTemplate(id int, name, content string) error {
    return fmt.Errorf("templates not supported in JSON store")
}
```

Place the new method near the existing template methods in both files (after DeleteTemplate).
  </action>
  <verify>Run `go build ./...` -- must compile with no errors. The compile-time interface checks (`var _ TodoStore = (*Store)(nil)` and `var _ TodoStore = (*SQLiteStore)(nil)`) ensure both implementations satisfy the interface.</verify>
  <done>UpdateTemplate exists on TodoStore interface, implemented in SQLiteStore (returns error on UNIQUE violation), stubbed in JSON Store. Project compiles.</done>
</task>

<task type="auto">
  <name>Task 2: Create internal/tmplmgr package with overlay model</name>
  <files>internal/tmplmgr/model.go, internal/tmplmgr/keys.go, internal/tmplmgr/styles.go</files>
  <action>
Create the `internal/tmplmgr/` directory and three files following the established overlay pattern (search, settings, preview).

**keys.go** -- Define KeyMap with bindings for overlay navigation and actions:
- Up (k/up): move cursor up in list
- Down (j/down): move cursor down in list
- Delete (d): delete selected template
- Rename (r): enter rename mode
- Edit (e): open in external editor (emits a message, handled by app layer)
- Confirm (enter): confirm rename
- Cancel (esc): close overlay or cancel current mode
Include ShortHelp/FullHelp methods and a DefaultKeyMap() constructor.

**styles.go** -- Define Styles struct with themed lipgloss styles:
- Title: bold, AccentFg (for "Templates" heading)
- TemplateName: NormalFg (template name in list)
- SelectedName: bold, AccentFg (selected template name)
- Separator: MutedFg (horizontal rule between list and preview)
- Content: NormalFg (template content preview area)
- Hint: MutedFg (bottom hint bar)
- Error: HolidayFg (for rename duplicate name error)
- Empty: MutedFg (for "no templates" message)
Include NewStyles(t theme.Theme) constructor.

**model.go** -- The core overlay model. Follow the search overlay pattern closely.

Define view mode enum:
```go
type viewMode int
const (
    listMode viewMode = iota
    renameMode
)
```

Define messages:
```go
type CloseMsg struct{}
type EditTemplateMsg struct{ Template store.Template }  // emitted when user presses 'e', app handles editor launch
type TemplateUpdatedMsg struct{}  // emitted after rename/delete so app can refresh if needed
```

Model struct:
```go
type Model struct {
    templates []store.Template
    cursor    int
    mode      viewMode
    store     store.TodoStore
    width     int
    height    int
    keys      KeyMap
    styles    Styles
    input     textinput.Model  // for rename
    err       string           // error message (e.g., duplicate name)
}
```

Constructor `New(s store.TodoStore, t theme.Theme) Model`:
- Call s.ListTemplates() to populate templates
- Initialize textinput.Model for rename (not focused initially)
- Set keys and styles
- Return fresh model

`SetSize(w, h int)`, `SetTheme(t theme.Theme)`, `HelpBindings() []key.Binding` methods following search/preview pattern.

`RefreshTemplates()` method that reloads templates from store (called after delete/rename).

**Update(msg tea.Msg) (Model, tea.Cmd):**

In listMode:
- Esc: emit CloseMsg via `func() tea.Msg { return CloseMsg{} }`
- j/down: cursor++ (clamp to len-1)
- k/up: cursor-- (clamp to 0)
- d: delete selected template via `m.store.DeleteTemplate(id)`, call RefreshTemplates(), clamp cursor, emit TemplateUpdatedMsg
- r: switch to renameMode, set m.input value to current template name, focus the input
- e: emit EditTemplateMsg with the selected template (app layer handles the editor launch)

In renameMode:
- Esc: switch back to listMode, clear error
- Enter: attempt rename. Get new name from m.input.Value(). If empty or unchanged, switch back to listMode. Otherwise call m.store.UpdateTemplate(id, newName, template.Content). If error (UNIQUE constraint), set m.err to "Name already exists". If success, call RefreshTemplates(), switch to listMode, clear error.
- Forward other keys to m.input.Update(msg)

**View() string:**

Build the view as a string builder (following search overlay pattern):

1. Title: "Templates" in Title style
2. Blank line
3. Template list: iterate templates, show cursor indicator (> for selected), template name. In renameMode for the selected item, show the textinput instead of the name.
4. If m.err is set, show error below input in Error style.
5. Horizontal separator line (use strings.Repeat with box-drawing character or dashes)
6. Content preview: show selected template's Content as raw text (NOT glamour-rendered -- REQ-21 specifies raw markdown to show placeholder syntax). Limit visible lines to available height.
7. Hint bar at bottom showing available keys based on mode.

If no templates exist, show "(no templates)" in Empty style.

Vertically center the content if height allows (same pattern as search overlay).

Important implementation notes:
- Template content is shown as RAW text, not glamour-rendered. This is intentional per REQ-21 so users can see {{.Placeholder}} syntax.
- No confirmation dialog on delete (matches todo delete pattern per REQ-22).
- Rename input is pre-filled with current name per REQ-23.
- Duplicate name error is shown inline per Pitfall 7 from PITFALLS.md.
  </action>
  <verify>Run `go build ./...` -- must compile. Run `go vet ./internal/tmplmgr/...` -- no issues. The package should compile independently (it depends on store and theme packages which exist).</verify>
  <done>internal/tmplmgr/ package exists with model.go (Model struct, New, Update, View, SetSize, SetTheme, HelpBindings, RefreshTemplates), keys.go (KeyMap with DefaultKeyMap), styles.go (Styles with NewStyles). Package compiles and follows the established overlay pattern. CloseMsg and EditTemplateMsg message types exported for app layer integration.</done>
</task>

</tasks>

<verification>
1. `go build ./...` passes (store interface satisfied, tmplmgr compiles)
2. `go vet ./...` passes
3. UpdateTemplate is on the TodoStore interface
4. tmplmgr package has Model with New, Update, View, SetSize, SetTheme, HelpBindings
5. tmplmgr exports CloseMsg, EditTemplateMsg, TemplateUpdatedMsg
</verification>

<success_criteria>
- Store interface extended with UpdateTemplate, implemented in SQLite (with error return for UNIQUE constraint), stubbed in JSON
- tmplmgr package created following the overlay pattern (search/settings/preview)
- Overlay supports: list with cursor nav, raw content preview, delete (d), rename (r) with pre-filled input and duplicate name handling
- EditTemplateMsg emitted for external editor (actual editor wiring happens in Plan 02)
- All code compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/20-template-management-overlay/20-01-SUMMARY.md`
</output>

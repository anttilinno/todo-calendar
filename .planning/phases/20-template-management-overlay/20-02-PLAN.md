---
phase: 20-template-management-overlay
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - internal/app/model.go
  - internal/app/keys.go
autonomous: true

must_haves:
  truths:
    - "Pressing M in normal mode opens the template management overlay"
    - "Esc in the overlay closes it and returns to the main view"
    - "Pressing e on a template opens it in the external editor"
    - "After editor saves, template content is updated in the store"
    - "Theme changes propagate to the tmplmgr overlay"
    - "Help bar shows tmplmgr-specific bindings when overlay is active"
    - "Window resize propagates to tmplmgr overlay"
    - "M key is listed in the expanded help bar"
  artifacts:
    - path: "internal/app/model.go"
      provides: "tmplmgr overlay routing, editor integration for templates"
      contains: "showTmplMgr"
    - path: "internal/app/keys.go"
      provides: "Templates key binding (M)"
      contains: "Templates"
  key_links:
    - from: "internal/app/model.go"
      to: "internal/tmplmgr/model.go"
      via: "tmplmgr.Model field on app.Model"
      pattern: "tmplmgr\\.Model"
    - from: "internal/app/model.go"
      to: "internal/tmplmgr/model.go"
      via: "tmplmgr.CloseMsg handling"
      pattern: "tmplmgr\\.CloseMsg"
    - from: "internal/app/model.go"
      to: "internal/tmplmgr/model.go"
      via: "tmplmgr.EditTemplateMsg handling"
      pattern: "tmplmgr\\.EditTemplateMsg"
    - from: "internal/app/model.go"
      to: "internal/editor/editor.go"
      via: "editor.Open for template content editing"
      pattern: "editor\\.Open"
---

<objective>
Wire the template management overlay into the app layer and integrate external editor support for template content editing.

Purpose: Connect the tmplmgr package (built in Plan 01) to the root app.Model so users can open the overlay with M, interact with templates, and edit template content via their external editor.
Output: Fully functional template management overlay accessible from normal mode.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-template-management-overlay/20-01-SUMMARY.md
@.planning/research/ARCHITECTURE.md
@internal/app/model.go
@internal/app/keys.go
@internal/editor/editor.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Templates key binding to app KeyMap</name>
  <files>internal/app/keys.go</files>
  <action>
Add a `Templates` field to the KeyMap struct:
```go
Templates key.Binding
```

In DefaultKeyMap(), add:
```go
Templates: key.NewBinding(
    key.WithKeys("M"),
    key.WithHelp("M", "templates"),
),
```

Note: uppercase M (Shift+m) per REQ-25 -- this follows the convention where uppercase letters are used for "heavier" operations.

Add Templates to the ShortHelp and FullHelp return slices alongside existing keys (Settings, Search, etc.).
  </action>
  <verify>Run `go build ./internal/app/...` -- compiles.</verify>
  <done>KeyMap has Templates field bound to "M" with help text "templates".</done>
</task>

<task type="auto">
  <name>Task 2: Wire tmplmgr overlay into app.Model</name>
  <files>internal/app/model.go</files>
  <action>
This task wires the tmplmgr overlay into app.Model following the exact pattern used by settings, search, and preview overlays. Add import for `"github.com/antti/todo-calendar/internal/tmplmgr"`.

**1. Add fields to Model struct:**
```go
showTmplMgr bool
tmplMgr     tmplmgr.Model
```

**2. Handle tmplmgr messages in the top-level switch (alongside other close messages):**

Add these cases in the message switch at the top of Update(), near the search.CloseMsg and preview.CloseMsg handlers:

```go
case tmplmgr.CloseMsg:
    m.showTmplMgr = false
    return m, nil

case tmplmgr.EditTemplateMsg:
    // Reuse the external editor pattern from Phase 16.
    // EditorFinishedMsg handling below will detect template edits via a negative TodoID convention
    // or we track the template being edited separately.
    m.editing = true
    tpl := msg.Template
    return m, editorOpenTemplate(tpl.ID, tpl.Name, tpl.Content)

case tmplmgr.TemplateUpdatedMsg:
    // Template was renamed or deleted in the overlay. No action needed at app level
    // since tmplmgr manages its own template list. This msg exists for future use
    // (e.g., if todolist caches templates).
    return m, nil
```

For the external editor integration with templates, we need a way to distinguish template edits from todo body edits when EditorFinishedMsg arrives. The cleanest approach: create a helper function `editorOpenTemplate` that works like editor.Open but uses a negative TodoID (or a dedicated field). However, to keep it simple and avoid modifying the editor package, track the template being edited in app.Model:

Add a field:
```go
editingTemplateID int  // non-zero when editing a template (not a todo)
```

In the tmplmgr.EditTemplateMsg handler:
```go
case tmplmgr.EditTemplateMsg:
    m.editing = true
    m.editingTemplateID = msg.Template.ID
    tpl := msg.Template
    // Use editor.Open with a sentinel TodoID of 0 (no todo).
    // Write template content without the "# title" heading since templates
    // are raw content, not todo bodies.
    return m, editorOpenTemplateContent(tpl.ID, tpl.Name, tpl.Content)
```

Create a helper function in model.go (NOT in the editor package) that opens the editor for template content:
```go
func editorOpenTemplateContent(templateID int, name, content string) tea.Cmd {
    f, err := os.CreateTemp("", "todo-calendar-template-*.md")
    if err != nil {
        return func() tea.Msg {
            return editor.EditorFinishedMsg{Err: err}
        }
    }
    // Write content directly (no # heading for templates)
    if _, err := f.WriteString(content); err != nil {
        f.Close()
        os.Remove(f.Name())
        return func() tea.Msg {
            return editor.EditorFinishedMsg{Err: err}
        }
    }
    if err := f.Close(); err != nil {
        os.Remove(f.Name())
        return func() tea.Msg {
            return editor.EditorFinishedMsg{Err: err}
        }
    }
    tempPath := f.Name()
    parts := strings.Fields(editor.ResolveEditor())
    args := append(parts[1:], tempPath)
    cmd := exec.Command(parts[0], args...)
    return tea.ExecProcess(cmd, func(err error) tea.Msg {
        return editor.EditorFinishedMsg{
            TempPath:     tempPath,
            OriginalBody: content,
            Err:          err,
        }
    })
}
```
Add necessary imports: `"os"`, `"os/exec"`, `"strings"`.

**3. Modify the EditorFinishedMsg handler** to handle template edits:

In the existing `case editor.EditorFinishedMsg:` block, add a branch for template editing:
```go
case editor.EditorFinishedMsg:
    m.editing = false
    if m.editingTemplateID != 0 {
        // Template content edit
        templateID := m.editingTemplateID
        m.editingTemplateID = 0
        defer os.Remove(msg.TempPath)
        if msg.Err != nil {
            return m, nil
        }
        data, err := os.ReadFile(msg.TempPath)
        if err != nil {
            return m, nil
        }
        newContent := strings.TrimRight(string(data), " \t\n")
        if newContent != msg.OriginalBody {
            tpl := m.store.FindTemplate(templateID)
            if tpl != nil {
                m.store.UpdateTemplate(templateID, tpl.Name, newContent)
            }
        }
        // Refresh tmplmgr's template list to show updated content
        m.tmplMgr.RefreshTemplates()
        return m, nil
    }
    // Existing todo body edit handling (unchanged)
    newBody, changed, err := editor.ReadResult(msg)
    os.Remove(msg.TempPath)
    if err != nil {
        return m, nil
    }
    if changed {
        m.store.UpdateBody(msg.TodoID, newBody)
    }
    m.calendar.RefreshIndicators()
    return m, nil
```

**4. Add overlay routing in Update():**

After the `if m.showSettings { return m.updateSettings(msg) }` block and BEFORE the `if m.showPreview` block (position 6.5 per ARCHITECTURE.md):
```go
if m.showTmplMgr {
    return m.updateTmplMgr(msg)
}
```

**5. Create updateTmplMgr method** (following the exact pattern of updateSettings, updateSearch, updatePreview):
```go
func (m Model) updateTmplMgr(msg tea.Msg) (tea.Model, tea.Cmd) {
    if wsm, ok := msg.(tea.WindowSizeMsg); ok {
        m.width = wsm.Width
        m.height = wsm.Height
        m.ready = true
        m.help.Width = wsm.Width
        m.tmplMgr.SetSize(wsm.Width, wsm.Height)
        var calCmd tea.Cmd
        m.calendar, calCmd = m.calendar.Update(msg)
        m.syncTodoSize()
        return m, calCmd
    }
    var cmd tea.Cmd
    m.tmplMgr, cmd = m.tmplMgr.Update(msg)
    return m, cmd
}
```

**6. Add key handler for M** in the normal-mode key switch (alongside Settings and Search handlers):
```go
case key.Matches(msg, m.keys.Templates) && !isInputting:
    m.tmplMgr = tmplmgr.New(m.store, theme.ForName(m.cfg.Theme))
    m.tmplMgr.SetSize(m.width, m.height)
    m.showTmplMgr = true
    return m, nil
```
Place this after the Search handler and before the Help handler.

**7. Add to View():**

After the `if m.showPreview { ... }` block and before the `if m.showSearch { ... }` block:
```go
if m.showTmplMgr {
    m.help.Width = m.width
    helpBar := m.help.View(m.currentHelpKeys())
    return lipgloss.JoinVertical(lipgloss.Left, m.tmplMgr.View(), helpBar)
}
```

**8. Add to applyTheme():**

After `m.preview.SetTheme(t)`:
```go
m.tmplMgr.SetTheme(t)
```

**9. Add to currentHelpKeys():**

After the `if m.showPreview { ... }` block:
```go
if m.showTmplMgr {
    return helpKeyMap{bindings: m.tmplMgr.HelpBindings()}
}
```

**10. Add Templates to expanded help bar:**

In the `if m.help.ShowAll { ... }` block within currentHelpKeys(), add `m.keys.Templates` alongside Tab, Settings, Search, Quit:
```go
bindings = append(bindings, m.keys.Tab, m.keys.Settings, m.keys.Search, m.keys.Templates, m.keys.Quit)
```

**11. Guard editor/tmplMgr overlay interaction:**

In the View() method, the existing `if m.editing { return "" }` guard already prevents TUI rendering during external editor sessions. This naturally handles the template edit case too since we set `m.editing = true`.
  </action>
  <verify>Run `go build ./...` -- must compile with no errors. Run `go vet ./...` -- no issues. Manually verify: launch the app with `go run .`, press M to open template overlay, navigate with j/k, see template content preview, press d to delete a template, press r to rename, press e to edit in external editor, press Esc to close overlay.</verify>
  <done>Template management overlay is fully wired: M opens overlay from normal mode, overlay shows template list with content preview, d deletes, r renames (with duplicate name handling), e opens external editor (content updates on save), Esc closes, theme/resize propagate, help bar shows overlay-specific keys, M appears in expanded help bar.</done>
</task>

</tasks>

<verification>
1. `go build ./...` passes
2. `go vet ./...` passes
3. Press M in normal mode -> template overlay opens
4. j/k navigation works, selected template content shown below separator
5. Press d -> template deleted, list refreshes
6. Press r -> rename mode with pre-filled name, Enter saves, duplicate name shows error
7. Press e -> external editor opens with template content, saving updates the template
8. Press Esc -> overlay closes, returns to normal view
9. M appears in expanded help bar (? toggle)
10. Theme changes via settings propagate to overlay
</verification>

<success_criteria>
- All 6 requirements (REQ-20 through REQ-25) are satisfied
- Template management overlay is accessible via M key
- Full CRUD operations work: view list, preview content, delete, rename, edit content
- Follows established overlay pattern (settings, search, preview)
- External editor integration reuses Phase 16 pattern
- Help bar integration works (overlay-specific keys when active, M in expanded normal mode)
</success_criteria>

<output>
After completion, create `.planning/phases/20-template-management-overlay/20-02-SUMMARY.md`
</output>

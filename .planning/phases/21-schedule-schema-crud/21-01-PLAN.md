---
phase: 21-schedule-schema-crud
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - internal/recurring/rule.go
  - internal/recurring/rule_test.go
autonomous: true

must_haves:
  truths:
    - "ParseRule correctly parses all four cadence formats: daily, weekdays, weekly:days, monthly:N"
    - "MatchesDate returns true for dates matching the cadence and false otherwise"
    - "Monthly day clamping works for short months (e.g., monthly:31 matches Feb 28 in non-leap year)"
    - "String() round-trips back to parseable format"
    - "ParseRule returns descriptive error for invalid input"
  artifacts:
    - path: "internal/recurring/rule.go"
      provides: "ScheduleRule type with ParseRule, MatchesDate, String"
      exports: ["ScheduleRule", "ParseRule"]
    - path: "internal/recurring/rule_test.go"
      provides: "Comprehensive test coverage for all cadence types"
      min_lines: 80
  key_links:
    - from: "internal/recurring/rule_test.go"
      to: "internal/recurring/rule.go"
      via: "import and test all exported functions"
      pattern: "recurring\\.ParseRule"
---

<objective>
Create the internal/recurring package with ScheduleRule type that can parse and match all four cadence types (daily, weekdays, weekly, monthly) using TDD.

Purpose: This is the core business logic for recurring schedules. Rule parsing and date matching must be correct, especially monthly edge cases. TDD ensures correctness before integration.
Output: Fully tested rule.go + rule_test.go in internal/recurring/
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<feature>
  <name>ScheduleRule parsing and date matching</name>
  <files>internal/recurring/rule.go, internal/recurring/rule_test.go</files>
  <behavior>
    ScheduleRule represents a recurring cadence. It has fields:
    - Type string: one of "daily", "weekdays", "weekly", "monthly"
    - Days []string: for weekly type, lowercase day names (e.g., ["mon", "fri"])
    - DayOfMonth int: for monthly type, 1-31 (0 means unused)

    ParseRule(s string) (ScheduleRule, error):
    - "daily" -> ScheduleRule{Type: "daily"}
    - "weekdays" -> ScheduleRule{Type: "weekdays"}
    - "weekly:mon,wed,fri" -> ScheduleRule{Type: "weekly", Days: ["mon", "wed", "fri"]}
    - "monthly:15" -> ScheduleRule{Type: "monthly", DayOfMonth: 15}
    - Invalid input -> descriptive error

    MatchesDate(d time.Time) bool:
    - daily: always true
    - weekdays: true for Monday-Friday
    - weekly: true if d.Weekday() matches any day in Days
    - monthly: true if d.Day() == DayOfMonth, WITH CLAMPING: if DayOfMonth > days-in-month, match the last day of the month (e.g., monthly:31 matches Jan 31, Feb 28/29, Mar 31, Apr 30)

    String() string:
    - Round-trips: ParseRule(rule.String()) should equal the original rule
    - "daily", "weekdays", "weekly:mon,wed,fri", "monthly:15"

    Test cases:
    - ParseRule("daily") -> Type="daily", MatchesDate(any) = true
    - ParseRule("weekdays") -> matches Mon-Fri, not Sat/Sun
    - ParseRule("weekly:mon,fri") -> matches Monday and Friday only
    - ParseRule("weekly:tue") -> matches Tuesday only
    - ParseRule("monthly:15") -> matches 15th of any month
    - ParseRule("monthly:31") -> matches Jan 31, Feb 28 (non-leap), Feb 29 (leap), Apr 30
    - ParseRule("monthly:29") -> matches Feb 29 in leap year, Feb 28 in non-leap year
    - ParseRule("") -> error
    - ParseRule("weekly:") -> error (no days)
    - ParseRule("monthly:0") -> error (invalid day)
    - ParseRule("monthly:32") -> error (out of range)
    - ParseRule("weekly:xyz") -> error (invalid day name)
    - ParseRule("unknown") -> error
    - String() round-trip for all valid types
  </behavior>
  <implementation>
    Package: internal/recurring

    rule.go:
    - Define ScheduleRule struct with Type, Days, DayOfMonth fields
    - validDays map for weekday name validation: mon, tue, wed, thu, fri, sat, sun
    - dayNameToWeekday map: "mon" -> time.Monday, etc.
    - ParseRule: split on ":", switch on type, validate and populate fields
    - MatchesDate: switch on Type, implement each cadence
    - For monthly clamping: use time.Date(y, m+1, 0, ...).Day() to get last day of month. If DayOfMonth > lastDay, match on lastDay.
    - String: switch on Type, format back to parseable string
  </implementation>
</feature>

<verification>
- `cd /home/antti/Repos/Misc/todo-calendar && go test ./internal/recurring/ -v` -- all tests pass
- `cd /home/antti/Repos/Misc/todo-calendar && go vet ./internal/recurring/` -- no issues
- Tests cover: all 4 cadence types parsing, matching, non-matching, monthly clamping (Feb 28/29, Apr 30), error cases, String() round-trips
</verification>

<success_criteria>
- ParseRule handles all four cadence types correctly
- MatchesDate returns correct results for each cadence type
- Monthly clamping works for short months (Feb 28/29, Apr 30)
- ParseRule returns errors for invalid input (empty, bad day names, out of range)
- String() round-trips through ParseRule
- All tests pass, go vet clean
</success_criteria>

<output>
After completion, create `.planning/phases/21-schedule-schema-crud/21-01-SUMMARY.md`
</output>

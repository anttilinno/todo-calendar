---
phase: 22-auto-creation-schedule-ui
plan: 03
type: execute
wave: 2
depends_on: ["22-02"]
files_modified:
  - internal/tmplmgr/model.go
  - internal/tmplmgr/keys.go
  - internal/tmplmgr/styles.go
autonomous: true

must_haves:
  truths:
    - "User presses S on a template to open schedule picker"
    - "Left/right arrows cycle cadence type (None/Daily/Weekdays/Weekly/Monthly)"
    - "For weekly: j/k moves weekday cursor, space toggles individual days"
    - "For monthly: text input accepts day number 1-31"
    - "Enter saves schedule to store, Esc cancels"
    - "Existing schedule is loaded when entering picker"
    - "Setting cadence to None deletes existing schedule"
  artifacts:
    - path: "internal/tmplmgr/model.go"
      provides: "scheduleMode with cadence cycling, weekly toggling, monthly input"
      contains: "scheduleMode"
    - path: "internal/tmplmgr/keys.go"
      provides: "Schedule, Left, Right, Toggle key bindings"
      contains: "Schedule"
    - path: "internal/tmplmgr/styles.go"
      provides: "ScheduleActive, ScheduleInactive, ScheduleDay, ScheduleDaySelected styles"
      contains: "ScheduleActive"
  key_links:
    - from: "internal/tmplmgr/model.go"
      to: "store.TodoStore"
      via: "AddSchedule/UpdateSchedule/DeleteSchedule/ListSchedulesForTemplate"
      pattern: "AddSchedule|UpdateSchedule|DeleteSchedule"
    - from: "internal/tmplmgr/model.go"
      to: "internal/recurring/rule.go"
      via: "ParseRule for loading existing schedule into picker"
      pattern: "recurring\\.ParseRule"
---

<objective>
Implement the schedule picker UI in the template management overlay with cadence type cycling, weekly weekday toggling, and monthly day input.

Purpose: REQ-29 (schedule picker). Users can attach recurring schedules to templates. Placeholder defaults prompting is handled separately in Plan 04.
Output: Working schedule picker that saves schedules with "{}" as placeholder defaults.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-auto-creation-schedule-ui/22-02-SUMMARY.md
@internal/tmplmgr/model.go
@internal/tmplmgr/keys.go
@internal/tmplmgr/styles.go
@internal/store/store.go
@internal/store/todo.go
@internal/recurring/rule.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schedule picker keys and styles</name>
  <files>internal/tmplmgr/keys.go, internal/tmplmgr/styles.go</files>
  <action>
    **keys.go changes:**
    - Add `Schedule key.Binding` to KeyMap with key "s", help "s", description "schedule"
    - Add `Left key.Binding` with keys "left", "h" and help "left/h", "prev type"
    - Add `Right key.Binding` with keys "right", "l" and help "right/l", "next type"
    - Add `Toggle key.Binding` with key "space" and help "space", "toggle"
    - Update DefaultKeyMap() to include all four new bindings
    - Update ShortHelp() to include Schedule in the existing list

    **styles.go changes:**
    - Add `ScheduleActive lipgloss.Style` to Styles struct -- bold, AccentFg (highlights the selected cadence type)
    - Add `ScheduleInactive lipgloss.Style` -- MutedFg (non-selected cadence types)
    - Add `ScheduleDay lipgloss.Style` -- NormalFg (weekday names when not toggled)
    - Add `ScheduleDaySelected lipgloss.Style` -- Bold, AccentFg (toggled-on weekday names)
    - Set all four in NewStyles() using the appropriate theme colors
  </action>
  <verify>`cd /home/antti/Repos/Misc/todo-calendar && go build ./internal/tmplmgr/...` compiles. `grep -n 'Schedule\|Left\|Right\|Toggle' internal/tmplmgr/keys.go` shows all 4 bindings. `grep -n 'ScheduleActive\|ScheduleInactive\|ScheduleDay' internal/tmplmgr/styles.go` shows all 4 styles.</verify>
  <done>KeyMap has Schedule/Left/Right/Toggle bindings. Styles has ScheduleActive/ScheduleInactive/ScheduleDay/ScheduleDaySelected.</done>
</task>

<task type="auto">
  <name>Task 2: Schedule picker mode in tmplmgr model</name>
  <files>internal/tmplmgr/model.go</files>
  <action>
    **Add imports:** "strconv", "encoding/json" (json needed later by Plan 04 but harmless to add now), and the recurring package "github.com/antti/todo-calendar/internal/recurring".

    **Add viewMode constant:** `scheduleMode` after renameMode.

    **Add schedule state fields to Model struct:**
    ```go
    // Schedule picker state
    cadenceTypes    []string        // ["none", "daily", "weekdays", "weekly", "monthly"]
    cadenceIndex    int             // which cadence type is selected
    weeklyDays      [7]bool         // Mon=0..Sun=6 toggles
    weekdayCursor   int             // 0-6, which weekday has focus
    monthlyInput    textinput.Model // text input for monthly day number
    editingSchedule *store.Schedule // non-nil when editing existing schedule
    ```

    **Initialize in New():**
    - Set `m.cadenceTypes = []string{"none", "daily", "weekdays", "weekly", "monthly"}`
    - Create monthlyInput: `textinput.New()` with Prompt "> ", CharLimit 2, Placeholder "1-31"

    **Add Schedule key handler in updateListMode() (new case after Edit):**
    When `key.Matches(msg, m.keys.Schedule)` and `m.selected() != nil`:
    1. Set `m.mode = scheduleMode`
    2. Reset state: `m.cadenceIndex = 0`, `m.weeklyDays = [7]bool{}`, `m.weekdayCursor = 0`, `m.monthlyInput.SetValue("")`, `m.editingSchedule = nil`
    3. Look up existing schedule: `scheds := m.store.ListSchedulesForTemplate(sel.ID)`
    4. If `len(scheds) > 0`:
       - Store `m.editingSchedule = &scheds[0]`
       - Build rule string: if `scheds[0].CadenceValue == ""` use `scheds[0].CadenceType`, else use `scheds[0].CadenceType + ":" + scheds[0].CadenceValue`
       - Parse with `recurring.ParseRule(ruleStr)`
       - On success, set cadenceIndex: "daily"->1, "weekdays"->2, "weekly"->3, "monthly"->4
       - For weekly: iterate rule.Days, map each to index (mon->0, tue->1, wed->2, thu->3, fri->4, sat->5, sun->6), set `m.weeklyDays[idx] = true`
       - For monthly: `m.monthlyInput.SetValue(strconv.Itoa(rule.DayOfMonth))`

    **Add updateScheduleMode(msg tea.KeyMsg) method:**
    Route to it from Update() when `m.mode == scheduleMode`.

    Implementation:
    ```
    Cancel (esc): m.mode = listMode, return m, nil

    Left: if cadenceIndex is NOT "monthly" (index 4), decrement with wrap:
      m.cadenceIndex = (m.cadenceIndex - 1 + len(m.cadenceTypes)) % len(m.cadenceTypes)
      return m, nil
      If cadenceIndex IS "monthly", also allow left (cycle away from monthly, blur input).

    Right: same logic, increment with wrap:
      m.cadenceIndex = (m.cadenceIndex + 1) % len(m.cadenceTypes)
      return m, nil

    Up (j/k): if cadence is "weekly" and weekdayCursor > 0, decrement weekdayCursor
    Down (j/k): if cadence is "weekly" and weekdayCursor < 6, increment weekdayCursor

    Toggle (space): if cadence is "weekly", flip m.weeklyDays[m.weekdayCursor]

    Confirm (enter): validate and save:
      1. sel := m.selected(); if nil, return to listMode
      2. Switch on m.cadenceTypes[m.cadenceIndex]:
         - "none":
           if m.editingSchedule != nil { m.store.DeleteSchedule(m.editingSchedule.ID) }
           m.mode = listMode
           m.RefreshTemplates()
           return m, func() tea.Msg { return TemplateUpdatedMsg{} }
         - "daily": cadenceType="daily", cadenceValue=""
         - "weekdays": cadenceType="weekdays", cadenceValue=""
         - "weekly":
           collect toggled days in weekday order (mon first, sun last)
           dayNames := []string for each index 0-6 where weeklyDays[i] is true, map to: [0]="mon",[1]="tue",[2]="wed",[3]="thu",[4]="fri",[5]="sat",[6]="sun"
           if len(dayNames) == 0 { m.err = "Select at least one day"; return m, nil }
           cadenceType="weekly", cadenceValue=strings.Join(dayNames, ",")
         - "monthly":
           dayStr := strings.TrimSpace(m.monthlyInput.Value())
           day, err := strconv.Atoi(dayStr)
           if err != nil || day < 1 || day > 31 { m.err = "Enter a day 1-31"; return m, nil }
           cadenceType="monthly", cadenceValue=dayStr
      3. Save:
         defaults := "{}"
         if m.editingSchedule != nil {
           defaults = m.editingSchedule.PlaceholderDefaults
           if defaults == "" { defaults = "{}" }
           m.store.UpdateSchedule(m.editingSchedule.ID, cadenceType, cadenceValue, defaults)
         } else {
           m.store.AddSchedule(sel.ID, cadenceType, cadenceValue, defaults)
         }
      4. m.mode = listMode, m.err = "", m.RefreshTemplates()
      5. return m, func() tea.Msg { return TemplateUpdatedMsg{} }
    ```

    For monthly input forwarding: when cadenceIndex is 4 ("monthly") and the key does NOT match Cancel, Confirm, Left, or Right, forward the msg to m.monthlyInput via `m.monthlyInput, cmd = m.monthlyInput.Update(msg)`. Focus monthlyInput when cadence changes TO monthly (in the left/right handlers, after updating cadenceIndex, check if new type is "monthly" and call `m.monthlyInput.Focus()`; if leaving monthly, call `m.monthlyInput.Blur()`).

    **Update Update() method to route scheduleMode:**
    In the `switch m.mode` within the `tea.KeyMsg` case, add `case scheduleMode: return m.updateScheduleMode(msg)`.

    **Update View() for scheduleMode:**
    Add a branch in View(): when `m.mode == scheduleMode`, render the schedule picker instead of the normal content preview area.

    Layout:
    ```
    Templates              (title, same as always)

    [template list as normal, with cursor on selected]

    ----------------------------------------

    Schedule: < None  Daily  Weekdays  Weekly  Monthly >

    [When weekly:]
      > Mon  [ ]
        Tue  [x]
        Wed  [ ]
        ...

    [When monthly:]
      Day of month: > [input]

    [error line if m.err != ""]

      left/right type | enter save | esc cancel
    [weekly adds:] j/k day | space toggle |
    [monthly shows:] type digits | enter save | esc cancel
    ```

    For the cadence type line: iterate m.cadenceTypes, render each name (capitalize first letter for display: "None", "Daily", etc.). Use ScheduleActive style for the one at cadenceIndex, ScheduleInactive for others. Prefix with "< " and suffix with " >".

    For weekly day grid: show 7 lines. Day names: "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun". For each day i, show ">" cursor if i == weekdayCursor, else "  ". Then the day name. Then " [x]" if weeklyDays[i] else " [ ]". Use ScheduleDaySelected for toggled-on day name, ScheduleDay for toggled-off.

    For monthly: show "  Day of month: " then m.monthlyInput.View().

    **Update hint bar in View():**
    - In the listMode hint string, add "s schedule" so it reads: `"  j/k navigate  |  r rename  |  d delete  |  e edit  |  s schedule  |  esc close"`
    - The scheduleMode hint is rendered inside the schedule picker View section (not the bottom hint bar).

    **Update HelpBindings():**
    Add case for scheduleMode. Return a set of relevant bindings:
    - Always: m.keys.Left, m.keys.Right, m.keys.Confirm, m.keys.Cancel
    - If cadence is "weekly": also m.keys.Up, m.keys.Down, m.keys.Toggle
  </action>
  <verify>
    `cd /home/antti/Repos/Misc/todo-calendar && go build ./...` compiles with no errors.
    `cd /home/antti/Repos/Misc/todo-calendar && go test ./...` all tests pass.
    `grep -n 'scheduleMode\|updateScheduleMode' internal/tmplmgr/model.go` shows mode constant and handler.
    `grep -n 'AddSchedule\|UpdateSchedule\|DeleteSchedule' internal/tmplmgr/model.go` shows store calls in confirm handler.
  </verify>
  <done>
    Schedule picker opens with S key. Left/right cycles 5 cadence types. Weekly shows day grid with j/k cursor + space toggle. Monthly shows text input for day 1-31. Enter validates and saves schedule (using "{}" or existing defaults for placeholder_defaults). Esc cancels. Existing schedules load into picker. Setting to None deletes schedule. Hint bar shows "s schedule" in list mode.
  </done>
</task>

</tasks>

<verification>
- `cd /home/antti/Repos/Misc/todo-calendar && go build ./...` compiles
- `cd /home/antti/Repos/Misc/todo-calendar && go test ./...` all tests pass
- Schedule picker opens with S key in template overlay
- All 5 cadence types cycle with left/right arrows
- Weekly mode: j/k moves cursor, space toggles days, at least one day required
- Monthly mode: accepts day number input, validates 1-31
- Enter saves schedule to store, Esc cancels
- Existing schedule pre-loads when opening picker on a scheduled template
- Setting cadence to None deletes existing schedule
</verification>

<success_criteria>
- Schedule picker lifecycle: open, configure, save, cancel
- All cadence types configurable (none, daily, weekdays, weekly, monthly)
- Weekly day toggling works with cursor navigation
- Monthly day number validated 1-31
- Saves with "{}" as placeholder defaults (Plan 04 adds prompting)
- Existing schedules editable (loads current values into picker)
- Setting cadence to "none" deletes existing schedule
- Build and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/22-auto-creation-schedule-ui/22-03-SUMMARY.md`
</output>

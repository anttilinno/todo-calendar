---
phase: 22-auto-creation-schedule-ui
plan: 03
type: execute
wave: 2
depends_on: ["22-02"]
files_modified:
  - internal/tmplmgr/model.go
  - internal/tmplmgr/keys.go
  - internal/tmplmgr/styles.go
autonomous: true

must_haves:
  truths:
    - "User presses S on a template to open schedule picker"
    - "Left/right arrows cycle cadence type (None/Daily/Weekdays/Weekly/Monthly)"
    - "For weekly: space toggles individual weekdays"
    - "For monthly: text input accepts day number 1-31"
    - "Enter saves schedule to store, Esc cancels"
    - "Existing schedule is loaded when entering picker"
    - "Templates with placeholders prompt for default values before saving"
  artifacts:
    - path: "internal/tmplmgr/model.go"
      provides: "scheduleMode and placeholderDefaultsMode with full picker logic"
      contains: "scheduleMode"
    - path: "internal/tmplmgr/keys.go"
      provides: "Schedule key binding"
      contains: "Schedule"
    - path: "internal/tmplmgr/styles.go"
      provides: "Schedule picker styles"
      contains: "ScheduleActive"
  key_links:
    - from: "internal/tmplmgr/model.go"
      to: "store.TodoStore"
      via: "AddSchedule/UpdateSchedule/DeleteSchedule/ListSchedulesForTemplate"
      pattern: "AddSchedule|UpdateSchedule|DeleteSchedule"
    - from: "internal/tmplmgr/model.go"
      to: "internal/tmpl/tmpl.go"
      via: "ExtractPlaceholders for detecting placeholder templates"
      pattern: "tmpl\\.ExtractPlaceholders"
    - from: "internal/tmplmgr/model.go"
      to: "internal/recurring/rule.go"
      via: "ParseRule for loading existing schedule"
      pattern: "recurring\\.ParseRule"
---

<objective>
Implement the schedule picker UI in the template management overlay, including cadence type cycling, weekday toggling, monthly day input, and placeholder defaults prompting.

Purpose: REQ-29 (schedule picker) and REQ-33 (placeholder defaults at schedule creation). Users can attach recurring schedules to templates and provide default placeholder values.
Output: Fully functional schedule picker integrated into tmplmgr overlay.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-auto-creation-schedule-ui/22-02-SUMMARY.md
@internal/tmplmgr/model.go
@internal/tmplmgr/keys.go
@internal/tmplmgr/styles.go
@internal/store/store.go
@internal/store/todo.go
@internal/tmpl/tmpl.go
@internal/recurring/rule.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schedule picker modes and key handling</name>
  <files>internal/tmplmgr/model.go, internal/tmplmgr/keys.go, internal/tmplmgr/styles.go</files>
  <action>
    **keys.go changes:**
    - Add `Schedule key.Binding` to KeyMap with key "s", help "s", description "schedule"
    - Add `Left key.Binding` and `Right key.Binding` with keys "left"/"h" and "right"/"l" respectively
    - Add `Toggle key.Binding` with key "space", help "space", description "toggle"
    - Update ShortHelp/FullHelp and DefaultKeyMap accordingly
    - In ShortHelp, keep existing keys and add Schedule

    **styles.go changes:**
    - Add `ScheduleActive lipgloss.Style` -- bold, AccentFg (highlights the selected cadence type)
    - Add `ScheduleInactive lipgloss.Style` -- MutedFg (non-selected cadence types)
    - Add `ScheduleDay lipgloss.Style` -- NormalFg (weekday names)
    - Add `ScheduleDaySelected lipgloss.Style` -- Bold, AccentFg (toggled-on weekday)
    - Add `SchedulePrompt lipgloss.Style` -- NormalFg (placeholder prompt text)

    **model.go changes:**

    Add two new viewMode constants:
    ```
    scheduleMode
    placeholderDefaultsMode
    ```

    Add schedule state fields to Model struct:
    ```
    // Schedule picker state
    cadenceTypes    []string       // ["none", "daily", "weekdays", "weekly", "monthly"]
    cadenceIndex    int            // which cadence type is selected
    weeklyDays      [7]bool        // Mon-Sun toggles (index 0=Mon, 6=Sun)
    monthlyDay      string         // text input value for monthly day number
    monthlyInput    textinput.Model // text input for monthly day
    editingSchedule *store.Schedule // non-nil if editing existing schedule

    // Placeholder defaults state
    placeholderNames  []string
    placeholderIndex  int
    placeholderValues map[string]string
    defaultsInput     textinput.Model
    ```

    Initialize cadenceTypes in New(): `m.cadenceTypes = []string{"none", "daily", "weekdays", "weekly", "monthly"}`

    Create monthlyInput in New(): textinput.New() with Prompt "> ", CharLimit 2, Placeholder "1-31"

    Create defaultsInput in New(): textinput.New() with Prompt "> ", CharLimit 200

    **Schedule key handler in updateListMode:**
    When key.Matches(msg, m.keys.Schedule) and selected template exists:
    1. Set mode = scheduleMode
    2. Look up existing schedule: `scheds := m.store.ListSchedulesForTemplate(sel.ID)`
    3. If schedule exists (len > 0):
       - Store it in m.editingSchedule
       - Parse cadence: build rule string from CadenceType+CadenceValue, use recurring.ParseRule
       - Set cadenceIndex based on rule.Type ("daily"->1, "weekdays"->2, "weekly"->3, "monthly"->4)
       - For weekly: set weeklyDays based on rule.Days (map day name to index: mon->0, tue->1, etc.)
       - For monthly: set monthlyDay and monthlyInput.SetValue(strconv.Itoa(rule.DayOfMonth))
    4. If no schedule: cadenceIndex=0 ("none"), clear all state, editingSchedule=nil

    **updateScheduleMode(msg tea.KeyMsg) handler:**
    - Cancel (esc): mode=listMode, clear schedule state
    - Left: cadenceIndex = (cadenceIndex - 1 + len) % len
    - Right: cadenceIndex = (cadenceIndex + 1) % len
    - For weekly (cadenceIndex==3):
      - Toggle (space): focus on weekday selector. Cycle through days with left/right, toggle with space.
      - Actually simpler: Use 1-7 number keys or m/t/w/T/f/s/S letter keys to toggle days.
      - Better approach: When cadenceIndex is "weekly", show all 7 days as toggleable. The left/right arrows now move between days instead of cadence types. Use a separate "weekday cursor" field. Space toggles the day at cursor. Left/right shift between "cadence selector" and "day selector" based on context. This is complex.
      - SIMPLEST approach matching REQ-29: left/right cycle cadence types globally. When weekly is selected, below the cadence line show 7 days. Space toggles the day under a weekday cursor. j/k or additional left/right within the day area. For simplicity: when in weekly mode, show days inline. Use keys 1-7 or the first letter of each day to toggle. Actually per REQ-29: "toggle individual weekdays with space" implies a cursor over days.
      - Implementation: Add `weekdayCursor int` field (0-6). When cadenceIndex==3 (weekly), left/right move weekdayCursor (not cadence type). To switch cadence type when in weekly, use left/right only when weekdayCursor is at boundary (cursor at 0 and left -> change to weekdays cadence; cursor at 6 and right -> change to monthly cadence). This is elegant but complex.
      - SIMPLEST clean approach: Left/right ALWAYS cycle cadence type. When weekly is active, show the 7 days below. Each day is a letter (M T W T F S S). Space toggles through them sequentially, or use a sub-cursor. Use up/down or j/k to move the weekday cursor when in weekly mode. Space toggles the day at weekday cursor.
      - Final approach: left/right cycle cadence types. When cadenceIndex==3 (weekly), the weekday area shows below. Tab or j/k moves a weekdayCursor among 7 days. Space toggles the day at weekdayCursor. This keeps cadence cycling clean.

    OK, let me simplify. Here is the definitive design:

    **Schedule picker interaction model:**
    - Left/right arrows ALWAYS cycle cadence type (None -> Daily -> Weekdays -> Weekly -> Monthly -> None)
    - When cadence is "weekly": 7 day buttons shown below. j/k (or up/down) move weekdayCursor. Space toggles the day.
    - When cadence is "monthly": a text input appears for day number (1-31). The monthlyInput is focused and accepts digits.
    - Enter: validates and saves (see below). Esc: cancels.

    Add `weekdayCursor int` to Model struct.

    **updateScheduleMode implementation:**
    ```
    case key.Matches(msg, m.keys.Cancel):
        m.mode = listMode
        // clear schedule state
        return m, nil

    case key.Matches(msg, m.keys.Left):
        if m.cadenceTypes[m.cadenceIndex] != "monthly": // don't cycle while typing
            m.cadenceIndex = (m.cadenceIndex - 1 + len(m.cadenceTypes)) % len(m.cadenceTypes)
        return m, nil

    case key.Matches(msg, m.keys.Right):
        if m.cadenceTypes[m.cadenceIndex] != "monthly":
            m.cadenceIndex = (m.cadenceIndex + 1) % len(m.cadenceTypes)
        return m, nil

    case key.Matches(msg, m.keys.Up):
        if m.cadenceTypes[m.cadenceIndex] == "weekly" && m.weekdayCursor > 0:
            m.weekdayCursor--
        return m, nil

    case key.Matches(msg, m.keys.Down):
        if m.cadenceTypes[m.cadenceIndex] == "weekly" && m.weekdayCursor < 6:
            m.weekdayCursor++
        return m, nil

    case key.Matches(msg, m.keys.Toggle):
        if m.cadenceTypes[m.cadenceIndex] == "weekly":
            m.weeklyDays[m.weekdayCursor] = !m.weeklyDays[m.weekdayCursor]
        return m, nil

    case key.Matches(msg, m.keys.Confirm):
        // validate and save -- see below
    ```

    For monthly: when cadenceIndex==4, forward non-navigation keys to monthlyInput. Focus monthlyInput when entering monthly. On left/right that would normally change cadence, check if monthlyInput is focused and has content -- always allow cadence change with left/right.

    Actually for monthly, since left/right should cycle cadence, do this: when cadenceIndex==4 (monthly), the monthlyInput is displayed and focused. All digit keys go to the input. Left/right still cycle cadence (blurring the input). Enter validates.

    Simplify: when cadenceIndex is "monthly", forward the key message to monthlyInput UNLESS it matches Cancel, Confirm, Left, or Right. This way digits and backspace go to the input, arrows still cycle cadence.

    **Confirm handler (Enter in scheduleMode):**
    1. Get selected template
    2. Build cadenceType and cadenceValue from current picker state:
       - cadenceIndex 0 (none): if editingSchedule exists, delete it. mode=listMode. Done.
       - cadenceIndex 1 (daily): type="daily", value=""
       - cadenceIndex 2 (weekdays): type="weekdays", value=""
       - cadenceIndex 3 (weekly): collect toggled days into sorted list (mon,tue,...). If none toggled, show error "Select at least one day". type="weekly", value=joined days
       - cadenceIndex 4 (monthly): parse monthlyInput.Value() as int. Validate 1-31. type="monthly", value=the number string
    3. Check if template has placeholders: call tmpl.ExtractPlaceholders(template.Content)
    4. If placeholders exist and (creating new schedule OR cadence changed):
       - Switch to placeholderDefaultsMode
       - Store cadenceType/cadenceValue in temp fields (pendingCadenceType, pendingCadenceValue)
       - Load existing defaults from editingSchedule.PlaceholderDefaults if editing (parse JSON)
       - Set placeholderNames, placeholderIndex=0
       - Pre-fill defaultsInput with existing default for first placeholder
       - Return
    5. If no placeholders: save directly
       - If editingSchedule: m.store.UpdateSchedule(editingSchedule.ID, cadenceType, cadenceValue, editingSchedule.PlaceholderDefaults)
       - Else: m.store.AddSchedule(template.ID, cadenceType, cadenceValue, "{}")
       - RefreshTemplates(), mode=listMode
       - Return TemplateUpdatedMsg

    Add `pendingCadenceType string` and `pendingCadenceValue string` to Model struct for passing between schedule and placeholder modes.

    **updatePlaceholderDefaultsMode(msg tea.KeyMsg) handler:**
    - Cancel (esc): mode=listMode, clear state
    - Confirm (enter):
      - Store current input value: placeholderValues[placeholderNames[placeholderIndex]] = defaultsInput.Value()
      - If more placeholders: placeholderIndex++, pre-fill next, return
      - If last placeholder: build JSON from placeholderValues (json.Marshal), save schedule:
        - If editingSchedule: UpdateSchedule with new defaults JSON
        - Else: AddSchedule with defaults JSON
        - RefreshTemplates(), mode=listMode, return TemplateUpdatedMsg
    - Other keys: forward to defaultsInput

    **View changes for scheduleMode:**
    Render schedule picker below the template list:
    ```
    Schedule: < None  Daily  Weekdays  Weekly  Monthly >

    [When weekly is selected:]
      > Mon  [ ]
        Tue  [x]
        Wed  [ ]
        Thu  [x]
        Fri  [ ]
        Sat  [ ]
        Sun  [ ]

    [When monthly is selected:]
      Day of month: [input]

    Hint: left/right cadence | enter save | esc cancel
    [When weekly:] Hint: j/k select day | space toggle | left/right cadence | enter save | esc cancel
    ```

    For the cadence type line: render each type, highlight the active one with ScheduleActive style, others with ScheduleInactive. Show < > arrows on the sides.

    For weekday toggles: show cursor (>) on weekdayCursor row. Show [x] or [ ] for toggled state. Day names: Mon, Tue, Wed, Thu, Fri, Sat, Sun. Use ScheduleDaySelected for toggled days, ScheduleDay for others.

    For monthly: show "Day of month: " + monthlyInput.View()

    **View changes for placeholderDefaultsMode:**
    ```
    Set default for "ProjectName" (1/3):
    > [input value]

    Hint: enter next | esc cancel
    ```
    Show SchedulePrompt style for the prompt text.

    **HelpBindings() update:**
    Add cases for scheduleMode and placeholderDefaultsMode:
    - scheduleMode: return relevant keys based on cadenceTypes[cadenceIndex]
    - placeholderDefaultsMode: return Confirm, Cancel

    **Add "s" key to listMode hint bar** (in View()):
    Update the hint string for list mode to include "s schedule":
    `"  j/k navigate  |  r rename  |  d delete  |  e edit  |  s schedule  |  esc close"`
  </action>
  <verify>
    `cd /home/antti/Repos/Misc/todo-calendar && go build ./...` compiles with no errors.
    `cd /home/antti/Repos/Misc/todo-calendar && go test ./...` all tests pass.
    `grep -n 'scheduleMode\|placeholderDefaultsMode' internal/tmplmgr/model.go` shows both modes.
    `grep -n 'Schedule' internal/tmplmgr/keys.go` shows Schedule binding.
  </verify>
  <done>
    User can press S on a template to open schedule picker. Left/right cycle cadence types (None/Daily/Weekdays/Weekly/Monthly). Weekly shows toggleable weekdays with j/k + space. Monthly shows day number input. Enter saves, Esc cancels. Templates with placeholders prompt for default values before saving. Existing schedules load into picker when opened.
  </done>
</task>

</tasks>

<verification>
- `cd /home/antti/Repos/Misc/todo-calendar && go build ./...` compiles
- `cd /home/antti/Repos/Misc/todo-calendar && go test ./...` all tests pass
- Schedule picker opens with S key in template overlay
- All 5 cadence types cycle with left/right arrows
- Weekly mode: j/k moves cursor, space toggles days
- Monthly mode: accepts day number input
- Enter saves schedule, Esc cancels
- Placeholder defaults prompt appears for templates with {{.Variable}} placeholders
- Existing schedule pre-loads when opening picker on a scheduled template
</verification>

<success_criteria>
- Full schedule picker lifecycle: open, configure, save, cancel
- All cadence types configurable (none, daily, weekdays, weekly, monthly)
- Weekly day toggling works with cursor navigation
- Monthly day number validated 1-31
- Placeholder defaults collected and stored as JSON
- Existing schedules editable (loads current values into picker)
- Setting cadence to "none" deletes existing schedule
- Build and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/22-auto-creation-schedule-ui/22-03-SUMMARY.md`
</output>

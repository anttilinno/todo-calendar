---
phase: 22-auto-creation-schedule-ui
plan: 04
type: execute
wave: 3
depends_on: ["22-03"]
files_modified:
  - internal/tmplmgr/model.go
  - internal/tmplmgr/styles.go
autonomous: true

must_haves:
  truths:
    - "When saving a schedule for a template with {{.Variable}} placeholders, user is prompted for default values"
    - "Each placeholder gets its own input step with name displayed"
    - "Defaults are stored as JSON in schedule.placeholder_defaults"
    - "Templates without placeholders skip prompting entirely"
    - "Editing an existing schedule pre-fills previously stored defaults"
    - "Esc cancels the entire flow and returns to list mode"
  artifacts:
    - path: "internal/tmplmgr/model.go"
      provides: "placeholderDefaultsMode with multi-step input and JSON save"
      contains: "placeholderDefaultsMode"
    - path: "internal/tmplmgr/styles.go"
      provides: "SchedulePrompt style for placeholder prompting"
      contains: "SchedulePrompt"
  key_links:
    - from: "internal/tmplmgr/model.go"
      to: "internal/tmpl/tmpl.go"
      via: "ExtractPlaceholders to detect templates needing defaults"
      pattern: "tmpl\\.ExtractPlaceholders"
    - from: "internal/tmplmgr/model.go"
      to: "encoding/json"
      via: "Marshal/Unmarshal for placeholder defaults JSON"
      pattern: "json\\.Marshal|json\\.Unmarshal"
    - from: "internal/tmplmgr/model.go"
      to: "store.TodoStore"
      via: "AddSchedule/UpdateSchedule with JSON defaults"
      pattern: "AddSchedule|UpdateSchedule"
---

<objective>
Add placeholder defaults prompting to the schedule save flow so that templates with {{.Variable}} placeholders collect default values before saving.

Purpose: REQ-33 (placeholder defaults at schedule creation). When auto-creating todos, the stored defaults fill template placeholders automatically.
Output: placeholderDefaultsMode that intercepts the schedule confirm handler when placeholders are detected.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-auto-creation-schedule-ui/22-03-SUMMARY.md
@internal/tmplmgr/model.go
@internal/tmplmgr/styles.go
@internal/tmpl/tmpl.go
@internal/store/store.go
@internal/store/todo.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Placeholder defaults prompting mode</name>
  <files>internal/tmplmgr/model.go, internal/tmplmgr/styles.go</files>
  <action>
    **styles.go change:**
    - Add `SchedulePrompt lipgloss.Style` to Styles struct -- NormalFg (used for placeholder name display)
    - Set in NewStyles(): `lipgloss.NewStyle().Foreground(t.NormalFg)`

    **model.go changes:**

    Import the tmpl package: `"github.com/antti/todo-calendar/internal/tmpl"`
    Import "encoding/json" (may already be added by Plan 03).

    **Add viewMode constant:** `placeholderDefaultsMode` after `scheduleMode`.

    **Add placeholder defaults state fields to Model struct:**
    ```go
    // Placeholder defaults state
    pendingCadenceType  string            // cadence type from schedule picker
    pendingCadenceValue string            // cadence value from schedule picker
    placeholderNames    []string          // ordered placeholder names from template
    placeholderIndex    int               // which placeholder is currently being filled
    placeholderValues   map[string]string // collected default values
    defaultsInput       textinput.Model   // text input for current placeholder
    ```

    **Initialize defaultsInput in New():**
    Create: `textinput.New()` with Prompt "> ", CharLimit 200.

    **Modify the Confirm handler in updateScheduleMode():**
    Currently (from Plan 03) the confirm handler saves directly with "{}" defaults. Change it to:

    After building cadenceType and cadenceValue but BEFORE saving:
    1. Get the selected template content: `sel := m.selected()`
    2. Call `placeholders, err := tmpl.ExtractPlaceholders(sel.Content)`
    3. If `err == nil && len(placeholders) > 0`:
       - Store `m.pendingCadenceType = cadenceType` and `m.pendingCadenceValue = cadenceValue`
       - Set `m.placeholderNames = placeholders`
       - Set `m.placeholderIndex = 0`
       - Initialize `m.placeholderValues = make(map[string]string)`
       - If editing existing schedule with non-empty PlaceholderDefaults:
         Parse existing defaults: `json.Unmarshal([]byte(m.editingSchedule.PlaceholderDefaults), &m.placeholderValues)` (ignore error, just means starting fresh)
       - Pre-fill defaultsInput with existing value for first placeholder if present: `m.defaultsInput.SetValue(m.placeholderValues[placeholders[0]])`
       - Focus defaultsInput: `m.defaultsInput.Focus()`, `m.defaultsInput.CursorEnd()`
       - Set `m.mode = placeholderDefaultsMode`
       - Return m, nil
    4. If no placeholders: save directly as before (existing Plan 03 logic with "{}" defaults)

    **Add updatePlaceholderDefaultsMode(msg tea.KeyMsg) method:**
    Route to it from Update() when `m.mode == placeholderDefaultsMode`.

    Implementation:
    ```
    Cancel (esc):
      m.mode = listMode
      m.err = ""
      m.defaultsInput.Blur()
      return m, nil

    Confirm (enter):
      1. Store current value: m.placeholderValues[m.placeholderNames[m.placeholderIndex]] = m.defaultsInput.Value()
      2. If m.placeholderIndex < len(m.placeholderNames) - 1:
         - m.placeholderIndex++
         - Pre-fill next: m.defaultsInput.SetValue(m.placeholderValues[m.placeholderNames[m.placeholderIndex]])
         - m.defaultsInput.CursorEnd()
         - return m, nil
      3. If last placeholder:
         - Build JSON: defaultsJSON, _ := json.Marshal(m.placeholderValues)
         - defaults := string(defaultsJSON)
         - sel := m.selected()
         - if m.editingSchedule != nil:
             m.store.UpdateSchedule(m.editingSchedule.ID, m.pendingCadenceType, m.pendingCadenceValue, defaults)
           else:
             m.store.AddSchedule(sel.ID, m.pendingCadenceType, m.pendingCadenceValue, defaults)
         - m.mode = listMode
         - m.err = ""
         - m.defaultsInput.Blur()
         - m.RefreshTemplates()
         - return m, func() tea.Msg { return TemplateUpdatedMsg{} }

    Default: forward to m.defaultsInput
      var cmd tea.Cmd
      m.defaultsInput, cmd = m.defaultsInput.Update(msg)
      return m, cmd
    ```

    **Update View() for placeholderDefaultsMode:**
    When `m.mode == placeholderDefaultsMode`, render below the template list and separator:
    ```
    Set default for "ProjectName" (1/3):
    > [input value]

      enter next | esc cancel
    ```
    - Use m.styles.SchedulePrompt to render the prompt line: `fmt.Sprintf("Set default for %q (%d/%d):", m.placeholderNames[m.placeholderIndex], m.placeholderIndex+1, len(m.placeholderNames))`
    - Below it: m.defaultsInput.View()
    - Hint line: "  enter next  |  esc cancel" (or "enter save" for last placeholder)

    **Update HelpBindings():**
    Add case for placeholderDefaultsMode: return `[]key.Binding{m.keys.Confirm, m.keys.Cancel}`
  </action>
  <verify>
    `cd /home/antti/Repos/Misc/todo-calendar && go build ./...` compiles with no errors.
    `cd /home/antti/Repos/Misc/todo-calendar && go test ./...` all tests pass.
    `grep -n 'placeholderDefaultsMode\|updatePlaceholderDefaultsMode' internal/tmplmgr/model.go` shows mode constant and handler.
    `grep -n 'ExtractPlaceholders' internal/tmplmgr/model.go` shows placeholder detection in confirm handler.
    `grep -n 'json.Marshal' internal/tmplmgr/model.go` shows JSON serialization of defaults.
    `grep -n 'SchedulePrompt' internal/tmplmgr/styles.go` shows prompt style.
  </verify>
  <done>
    When saving a schedule for a template with placeholders, the user is prompted to enter a default value for each placeholder in sequence. Defaults are serialized as JSON and stored in the schedule. Templates without placeholders skip prompting. Editing an existing schedule pre-fills previously stored default values. Esc cancels the entire flow.
  </done>
</task>

</tasks>

<verification>
- `cd /home/antti/Repos/Misc/todo-calendar && go build ./...` compiles
- `cd /home/antti/Repos/Misc/todo-calendar && go test ./...` all tests pass
- Scheduling a template WITH placeholders triggers prompting flow
- Scheduling a template WITHOUT placeholders saves directly (no prompting)
- Each placeholder shown by name with step counter (1/3, 2/3, etc.)
- Enter advances to next placeholder, final enter saves schedule
- Esc at any point cancels and returns to list mode
- Editing existing schedule pre-fills stored defaults in input fields
- Defaults stored as valid JSON string in schedule.placeholder_defaults
</verification>

<success_criteria>
- placeholderDefaultsMode with multi-step input flow works
- JSON serialization produces valid {"Key":"value"} format
- Transition from schedule confirm to placeholder prompting when placeholders detected
- Pre-fill works for existing schedule defaults
- Templates without placeholders skip prompting
- Build and all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/22-auto-creation-schedule-ui/22-04-SUMMARY.md`
</output>

---
phase: 24-unified-add-form
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/todolist/model.go
autonomous: true

must_haves:
  truths:
    - "Pressing 'a' in normal mode opens a full-pane form with Title, Date, Body, and Template fields"
    - "User can Tab between fields (Title -> Date -> Body -> Template -> Title)"
    - "Enter saves from Title or Date field; Ctrl+D saves from Body or Template field"
    - "Leaving Date empty creates a floating todo; filling Date creates a dated todo"
    - "Non-empty Body is saved via UpdateBody after Add"
    - "Help bar shows 'enter: confirm' on fields 0/1 and 'ctrl+d: save' on fields 2/3"
    - "Cursor blinks in the active field across all 4 input mode fields"
  artifacts:
    - path: "internal/todolist/model.go"
      provides: "Extended inputMode with 4-field form, saveAdd, Tab cycling, view rendering, help bindings"
      contains: "templateInput"
  key_links:
    - from: "updateInputMode"
      to: "saveAdd"
      via: "Enter on fields 0/1 or Ctrl+D on fields 2/3"
      pattern: "saveAdd"
    - from: "saveAdd"
      to: "store.Add + store.UpdateBody"
      via: "store API calls"
      pattern: "m\\.store\\.Add.*m\\.store\\.UpdateBody"
    - from: "editView inputMode branch"
      to: "templateInput"
      via: "renders all 4 fields for inputMode"
      pattern: "templateInput\\.View"
---

<objective>
Transform inputMode from a single-field title-only form into a 4-field full-pane add form (Title, Date, Body, Template) matching the established editMode pattern.

Purpose: Satisfies ADD-01, ADD-02, ADD-05, ADD-06 -- the core unified add flow replacing the old separate a/A/t entry points (A and t already removed in Phase 23).
Output: Modified `internal/todolist/model.go` with extended inputMode supporting all 4 fields, Tab cycling, field-aware save semantics, proper blink forwarding, updated view rendering, and context-aware help bindings.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-unified-add-form/24-RESEARCH.md
@internal/todolist/model.go
@internal/todolist/keys.go
@internal/todolist/styles.go
@internal/store/iface.go
@internal/store/todo.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend inputMode to 4-field form with save logic</name>
  <files>internal/todolist/model.go</files>
  <action>
Add a `templateInput textinput.Model` field to the Model struct (after `editField int`).

In `New()`, initialize the templateInput:
```go
tmplInput := textinput.New()
tmplInput.Placeholder = "Press Enter to select template"
tmplInput.Prompt = "> "
tmplInput.CharLimit = 0  // Read-only placeholder for Phase 25
```
And set it on the returned Model: `templateInput: tmplInput,`

Update the `editField` comment to document 4 fields: `// 0 = title, 1 = date, 2 = body, 3 = template`

**Modify the Add key handler in `updateNormalMode()`** (the `case key.Matches(msg, m.keys.Add):` block):
- Keep existing: `m.mode = inputMode`, set input placeholder/prompt/value, focus input
- ADD: `m.editField = 0` (reset field index to prevent stale state from prior add/edit)
- ADD: `m.dateInput.SetValue("")` (clear date from prior use)
- ADD: `m.bodyTextarea.SetValue("")` (clear body from prior use)
- ADD: `m.dateInput.Placeholder = m.datePlaceholder + " (empty = floating)"` (set date placeholder with format hint)

**Rewrite `updateInputMode()`** to handle all 4 fields with Tab cycling:

Replace the existing simple implementation with one that mirrors editMode's pattern:

1. **Ctrl+D save** (`key.Matches(msg, m.keys.Save)`): Call `m.saveAdd()` from any field (like editMode's Save).

2. **Enter/Confirm** (`key.Matches(msg, m.keys.Confirm)`):
   - If `editField == 2` (body): Forward Enter to bodyTextarea for newlines (same as editMode).
   - If `editField == 3` (template): Forward Enter to templateInput (Phase 25 will use this to open picker). For now, no-op since CharLimit=0.
   - If `editField == 0 or 1` (title/date): Call `m.saveAdd()`.

3. **Tab/SwitchField** (`key.Matches(msg, m.keys.SwitchField)`):
   - Cycle: 0 -> 1 -> 2 -> 3 -> 0
   - Field 0 (title): `m.editField = 1; m.input.Blur(); return m, m.dateInput.Focus()`
   - Field 1 (date): `m.editField = 2; m.dateInput.Blur(); return m, m.bodyTextarea.Focus()`
   - Field 2 (body): `m.editField = 3; m.bodyTextarea.Blur(); return m, m.templateInput.Focus()`
   - Field 3 (template): `m.editField = 0; m.templateInput.Blur(); return m, m.input.Focus()`

4. **Esc/Cancel** (`key.Matches(msg, m.keys.Cancel)`):
   - From fields 0 or 1: Cancel entirely -- reset all fields, return to normalMode.
   - From fields 2 or 3: Go back to field 0 (title) without cancelling (same pattern as editMode's body Esc).
   - Cancel cleanup: Blur all 4 fields, SetValue("") on input/dateInput, SetValue("") on bodyTextarea, reset editField to 0.

5. **Key forwarding** (default case): Forward to the active field based on editField:
   - 0: `m.input, cmd = m.input.Update(msg)`
   - 1: `m.dateInput, cmd = m.dateInput.Update(msg)`
   - 2: `m.bodyTextarea, cmd = m.bodyTextarea.Update(msg)`
   - 3: `m.templateInput, cmd = m.templateInput.Update(msg)` (will be no-op in Phase 24 since CharLimit=0)

**Add `saveAdd()` method** (after `saveEdit()`):

Pattern it after saveEdit() but using `store.Add()` instead of `store.Update()`:
```go
func (m Model) saveAdd() (Model, tea.Cmd) {
    text := strings.TrimSpace(m.input.Value())
    if text == "" {
        return m, nil
    }

    date := strings.TrimSpace(m.dateInput.Value())
    isoDate := ""
    if date != "" {
        var err error
        isoDate, err = config.ParseUserDate(date, m.dateLayout)
        if err != nil {
            // Invalid date -- focus date field
            m.editField = 1
            m.input.Blur()
            m.bodyTextarea.Blur()
            m.templateInput.Blur()
            return m, m.dateInput.Focus()
        }
    }

    todo := m.store.Add(text, isoDate)

    body := m.bodyTextarea.Value()
    if strings.TrimSpace(body) != "" {
        m.store.UpdateBody(todo.ID, body)
    }

    m.mode = normalMode
    m.input.Blur()
    m.dateInput.Blur()
    m.bodyTextarea.Blur()
    m.templateInput.Blur()
    m.input.SetValue("")
    m.dateInput.SetValue("")
    m.bodyTextarea.SetValue("")
    m.editField = 0
    return m, nil
}
```

**Update blink/tick forwarding** (lines ~277-293, the `switch m.mode` block that forwards non-key, non-resize messages):

Currently the inputMode case falls through to `default` which forwards to `m.input`. Change it so inputMode uses the same field-aware forwarding as editMode. Merge the two cases:

```go
case inputMode, editMode:
    if _, ok := msg.(tea.KeyMsg); !ok {
        if _, ok := msg.(tea.WindowSizeMsg); !ok {
            var cmd tea.Cmd
            switch m.editField {
            case 2:
                m.bodyTextarea, cmd = m.bodyTextarea.Update(msg)
            case 3:
                m.templateInput, cmd = m.templateInput.Update(msg)
            case 1:
                m.dateInput, cmd = m.dateInput.Update(msg)
            default:
                m.input, cmd = m.input.Update(msg)
            }
            return m, cmd
        }
    }
```

Note: editMode only has fields 0-2, so the `case 3` is harmless for editMode (never reached). This keeps the code unified.
  </action>
  <verify>
Run `go build ./...` -- must compile with no errors.
Run `go vet ./...` -- no warnings.
  </verify>
  <done>
inputMode now supports 4 fields (title, date, body, template) with Tab cycling, Enter/Ctrl+D save semantics, field-aware Esc behavior, proper blink forwarding, and a saveAdd() method that creates todos via store.Add() + optional UpdateBody().
  </done>
</task>

<task type="auto">
  <name>Task 2: Update view rendering and help bindings for multi-field inputMode</name>
  <files>internal/todolist/model.go</files>
  <action>
**Update `editView()`** -- replace the `case inputMode:` branch (currently renders only Title field) with a 4-field layout matching editMode's pattern:

```go
case inputMode:
    // Four fields: Title, Date, Body, Template
    b.WriteString(m.styles.FieldLabel.Render("Title"))
    b.WriteString("\n")
    b.WriteString(m.input.View())
    b.WriteString("\n\n")
    b.WriteString(m.styles.FieldLabel.Render("Date"))
    b.WriteString("\n")
    b.WriteString(m.dateInput.View())
    b.WriteString("\n\n")
    b.WriteString(m.styles.FieldLabel.Render("Body"))
    b.WriteString("\n")
    b.WriteString(m.bodyTextarea.View())
    b.WriteString("\n\n")
    b.WriteString(m.styles.FieldLabel.Render("Template"))
    b.WriteString("\n")
    b.WriteString(m.templateInput.View())
    b.WriteString("\n")
```

**Update the vertical centering guard** at the bottom of editView() -- inputMode now has a textarea (body), so it should NOT be vertically centered (same as editMode). Change the condition from:
```go
if m.height > 0 && m.mode != editMode && m.mode != templateContentMode {
```
to:
```go
if m.height > 0 && m.mode != editMode && m.mode != inputMode && m.mode != templateContentMode {
```

**Update `HelpBindings()`** -- the `case inputMode:` currently returns only `[Confirm, Cancel]`. Replace it with field-aware bindings matching editMode's pattern:

```go
case inputMode:
    if m.editField == 2 || m.editField == 3 {
        return []key.Binding{m.keys.SwitchField, m.keys.Save, m.keys.Cancel}
    }
    return []key.Binding{m.keys.SwitchField, m.keys.Confirm, m.keys.Cancel}
```

**Update `AllHelpBindings()`** -- same change for the `case inputMode:` branch:

```go
case inputMode:
    if m.editField == 2 || m.editField == 3 {
        return []key.Binding{m.keys.SwitchField, m.keys.Save, m.keys.Cancel}
    }
    return []key.Binding{m.keys.SwitchField, m.keys.Confirm, m.keys.Cancel}
```
  </action>
  <verify>
Run `go build ./...` -- must compile with no errors.
Run `go vet ./...` -- no warnings.
Run the application manually: `go run .` -- press `a`, verify 4 fields appear (Title, Date, Body, Template), Tab cycles between them, Enter saves from Title/Date, Ctrl+D saves from Body/Template, Esc from Title/Date cancels, Esc from Body/Template goes to Title. Help bar updates per field.
  </verify>
  <done>
inputMode editView() renders all 4 fields (Title, Date, Body, Template). No vertical centering (matches editMode). Help bar shows "tab: switch field" + "enter: confirm" on fields 0/1 and "tab: switch field" + "ctrl+d: save" on fields 2/3.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go vet ./...` passes without warnings
3. Manual test: press `a` -> form shows Title, Date, Body, Template labels with input fields
4. Manual test: Tab cycles Title -> Date -> Body -> Template -> Title (4-field cycle)
5. Manual test: Type title + Enter from Title field -> floating todo created
6. Manual test: Type title + date + Enter from Date field -> dated todo created
7. Manual test: Type title + Tab + Tab + type body + Ctrl+D -> todo with body created
8. Manual test: Esc from Title or Date -> form cancelled
9. Manual test: Esc from Body or Template -> cursor moves to Title (no cancel)
10. Manual test: Help bar updates based on active field
11. Manual test: Cursor blinks in each field when focused
</verification>

<success_criteria>
- The `a` key opens a full-pane 4-field form (ADD-01)
- Tab cycles Title -> Date -> Body -> Template -> Title (ADD-02)
- Enter saves from Title/Date; Ctrl+D saves from Body/Template (ADD-05)
- Empty date creates floating todo; filled date creates dated todo (ADD-06)
- Non-empty body is persisted via UpdateBody
- Help bar is context-aware per field
- No regressions: editMode still works identically, build passes, vet passes
</success_criteria>

<output>
After completion, create `.planning/phases/24-unified-add-form/24-01-SUMMARY.md`
</output>

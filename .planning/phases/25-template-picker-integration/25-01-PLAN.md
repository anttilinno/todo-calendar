---
phase: 25-template-picker-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/todolist/model.go
autonomous: true

must_haves:
  truths:
    - "Pressing Enter on the Template field (editField=3) in inputMode opens a template picker list"
    - "j/k navigates the picker list, Enter selects a template"
    - "Selecting a template with no placeholders pre-fills Title with template name and Body with rendered content"
    - "Selecting a template with placeholders prompts for each value before pre-filling"
    - "After pre-fill, user is on editField=0 (Title) and can edit Title and Body before saving"
    - "Esc in picker returns to Template field; Esc in placeholder prompting returns to picker"
    - "Help bar updates for picker (j/k/enter/esc) and prompting (enter/esc) sub-states"
  artifacts:
    - path: "internal/todolist/model.go"
      provides: "Template picker and placeholder prompting within inputMode"
      contains: "pickingTemplate"
  key_links:
    - from: "internal/todolist/model.go updateTemplatePicker"
      to: "internal/tmpl/tmpl.go"
      via: "tmpl.ExtractPlaceholders and tmpl.ExecuteTemplate"
      pattern: "tmpl\\.ExtractPlaceholders|tmpl\\.ExecuteTemplate"
    - from: "internal/todolist/model.go updateInputMode"
      to: "updateTemplatePicker"
      via: "pickingTemplate check before existing key handlers"
      pattern: "m\\.pickingTemplate"
    - from: "internal/todolist/model.go updateTemplatePicker"
      to: "internal/store (ListTemplates)"
      via: "store.ListTemplates() to populate picker"
      pattern: "m\\.store\\.ListTemplates"
---

<objective>
Wire the Template field in the add form to a functional inline template picker with placeholder prompting, pre-filling Title and Body after selection.

Purpose: Completes ADD-03 and ADD-04 -- the final requirements for the v1.7 milestone. Users can now select templates from within the add form to pre-fill title and body, then edit before saving.

Output: Updated `internal/todolist/model.go` with picker sub-state logic, rendering, and help bindings.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-template-picker-integration/25-RESEARCH.md
@internal/todolist/model.go
@internal/todolist/keys.go
@internal/todolist/styles.go
@internal/tmpl/tmpl.go
@internal/store/iface.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add template picker state, update logic, and blink forwarding</name>
  <files>internal/todolist/model.go</files>
  <action>
Add import for `"github.com/antti/todo-calendar/internal/tmpl"` to model.go.

Add 8 new fields to the Model struct after the existing `templateInput` field:

```go
// Template picker sub-state (within inputMode)
pickingTemplate         bool
pickerTemplates         []store.Template
pickerCursor            int
promptingPlaceholders   bool
pickerPlaceholderNames  []string
pickerPlaceholderIndex  int
pickerPlaceholderValues map[string]string
pickerSelectedTemplate  *store.Template
```

In `updateInputMode`, add early returns for picker sub-states BEFORE the existing switch statement. This is critical to prevent Esc in the picker from falling through to the cancel handler:

```go
func (m Model) updateInputMode(msg tea.KeyMsg) (Model, tea.Cmd) {
    // Template picker sub-states intercept all keys
    if m.pickingTemplate {
        return m.updateTemplatePicker(msg)
    }
    if m.promptingPlaceholders {
        return m.updatePlaceholderPrompting(msg)
    }
    // ... existing switch cases unchanged
```

In the existing `Confirm` handler within `updateInputMode`, replace the `editField == 3` no-op with the picker open logic:

```go
if m.editField == 3 {
    templates := m.store.ListTemplates()
    if len(templates) == 0 {
        return m, nil // No templates available
    }
    m.pickingTemplate = true
    m.pickerTemplates = templates
    m.pickerCursor = 0
    return m, nil
}
```

Add three new methods to model.go:

1. `updateTemplatePicker(msg tea.KeyMsg) (Model, tea.Cmd)` -- handles j/k navigation, Enter to select (checks for placeholders via `tmpl.ExtractPlaceholders`; if none, calls `prefillFromTemplate` immediately; if has placeholders, transitions to prompting sub-state), Esc to cancel back to editField=3. See RESEARCH.md "Template Picker Key Handling" code example. Use `m.templateInput.Focus()` on cancel return, and `m.input.Focus()` when entering placeholder prompting or pre-fill.

2. `updatePlaceholderPrompting(msg tea.KeyMsg) (Model, tea.Cmd)` -- handles Enter to capture current value and advance index (when all filled, render via `tmpl.ExecuteTemplate` and call `prefillFromTemplate`), Esc to go back to picker (set `promptingPlaceholders=false`, `pickingTemplate=true`, blur input). For non-key messages, forward to `m.input.Update(msg)`. See RESEARCH.md "Placeholder Prompting Key Handling" code example.

3. `prefillFromTemplate(t *store.Template, renderedBody string) Model` -- resets all picker state, sets `m.input.SetValue(t.Name)` (Title), restores input Placeholder to "What needs doing?" and Prompt to "> ", calls `m.input.CursorEnd()`, sets `m.bodyTextarea.SetValue(renderedBody)` (Body), sets `m.templateInput.SetValue(t.Name)` (Template display), sets `m.editField = 0`, and returns m. See RESEARCH.md "Pre-fill Helper" code example.

Update blink forwarding in the `Update` method (lines 290-306 area). Add a check for `promptingPlaceholders` before the editField switch so that blink messages reach `m.input` during placeholder prompting regardless of editField value:

```go
case inputMode, editMode:
    if _, ok := msg.(tea.KeyMsg); !ok {
        if _, ok := msg.(tea.WindowSizeMsg); !ok {
            var cmd tea.Cmd
            // During placeholder prompting, always forward to m.input
            if m.promptingPlaceholders {
                m.input, cmd = m.input.Update(msg)
                return m, cmd
            }
            switch m.editField {
            // ... existing cases
```

Update `saveAdd` to also clear picker state:

```go
// After existing clears (input, dateInput, bodyTextarea, templateInput), add:
m.templateInput.SetValue("")
m.pickingTemplate = false
m.promptingPlaceholders = false
m.pickerSelectedTemplate = nil
m.pickerTemplates = nil
m.pickerPlaceholderNames = nil
m.pickerPlaceholderValues = nil
```

Update the cancel handler in `updateInputMode` (the Esc in title/date branch) to also clear picker state and templateInput:

```go
m.templateInput.SetValue("")
m.templateInput.Blur()
```

Note: The templateInput.Blur() call is already there. Just add the SetValue("") and any missing picker state resets.

Also update the "Esc in body/template goes back to title" branch to clear picker state if any is lingering.
  </action>
  <verify>
Run `go build ./...` -- must compile with no errors.
Run `go vet ./...` -- must pass with no warnings.
  </verify>
  <done>
Template picker opens when pressing Enter on editField=3, navigates with j/k, selects with Enter, cancels with Esc. Placeholder prompting works for templates with variables. Pre-fill sets Title, Body, and Template display fields. All state is cleaned up on save and cancel. Blink messages reach input during placeholder prompting.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update editView rendering and help bindings for picker sub-states</name>
  <files>internal/todolist/model.go</files>
  <action>
Update `editView()` to render picker and prompting sub-states. In the `case inputMode:` branch, add conditional rendering BEFORE the existing 4-field form:

```go
case inputMode:
    if m.pickingTemplate {
        // Render "Select Template" heading + template list with cursor
        b.WriteString(m.styles.EditTitle.Render("Select Template"))
        b.WriteString("\n\n")
        for i, t := range m.pickerTemplates {
            if i == m.pickerCursor {
                b.WriteString(m.styles.Cursor.Render("> "))
            } else {
                b.WriteString("  ")
            }
            b.WriteString(t.Name)
            // Brief inline preview (40 chars, single line)
            preview := t.Content
            if len(preview) > 40 {
                preview = preview[:40] + "..."
            }
            preview = strings.ReplaceAll(preview, "\n", " ")
            b.WriteString("  " + m.styles.Empty.Render(preview))
            b.WriteString("\n")
        }
    } else if m.promptingPlaceholders {
        // Render placeholder prompt heading + input field
        title := fmt.Sprintf("Fill Placeholder (%d/%d)",
            m.pickerPlaceholderIndex+1, len(m.pickerPlaceholderNames))
        b.WriteString(m.styles.EditTitle.Render(title))
        b.WriteString("\n\n")
        b.WriteString(m.styles.FieldLabel.Render(
            m.pickerPlaceholderNames[m.pickerPlaceholderIndex]))
        b.WriteString("\n")
        b.WriteString(m.input.View())
        b.WriteString("\n")
    } else {
        // Normal 4-field form (existing code stays here unchanged)
        b.WriteString(m.styles.FieldLabel.Render("Title"))
        // ... rest of existing inputMode rendering
    }
```

The existing 4-field rendering (Title, Date, Body, Template labels + views) moves inside the `else` branch. The structure becomes: `if pickingTemplate { ... } else if promptingPlaceholders { ... } else { existing 4-field form }`.

Update `HelpBindings()` in the `case inputMode:` branch. Add picker/prompting checks BEFORE the existing editField checks:

```go
case inputMode:
    if m.pickingTemplate {
        return []key.Binding{m.keys.Up, m.keys.Down, m.keys.Confirm, m.keys.Cancel}
    }
    if m.promptingPlaceholders {
        return []key.Binding{m.keys.Confirm, m.keys.Cancel}
    }
    // ... existing editField-based logic unchanged
```

Update `AllHelpBindings()` identically in the `case inputMode:` branch:

```go
case inputMode:
    if m.pickingTemplate {
        return []key.Binding{m.keys.Up, m.keys.Down, m.keys.Confirm, m.keys.Cancel}
    }
    if m.promptingPlaceholders {
        return []key.Binding{m.keys.Confirm, m.keys.Cancel}
    }
    // ... existing editField-based logic unchanged
```
  </action>
  <verify>
Run `go build ./...` -- must compile.
Run `go vet ./...` -- must pass.
Manually verify by reading the editView function that the three branches (pickingTemplate, promptingPlaceholders, normal form) are present and the else wraps the existing 4-field form code.
  </verify>
  <done>
editView renders template picker list when pickingTemplate=true, placeholder prompt when promptingPlaceholders=true, and normal 4-field form otherwise. Help bar shows j/k/enter/esc in picker mode and enter/esc in prompting mode.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles successfully
2. `go vet ./...` passes with no warnings
3. Run the app (`go run .`) and test the full flow:
   - Press `a` to open add form
   - Tab to Template field (field 3)
   - Press Enter -- should show template picker list (if templates exist)
   - Navigate with j/k, select with Enter
   - If template has placeholders, prompts appear one by one
   - After selection, Title and Body are pre-filled, cursor is on Title field
   - Can edit Title and Body before saving
   - Esc in picker returns to Template field
   - Esc in prompting returns to picker
   - Help bar updates correctly for each sub-state
</verification>

<success_criteria>
- ADD-03 satisfied: Template field opens template picker; selecting a template pre-fills Title and Body
- ADD-04 satisfied: User can edit pre-filled Title and Body after template selection before saving
- All three phase success criteria from ROADMAP.md are met
- `go build` and `go vet` pass cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/25-template-picker-integration/25-01-SUMMARY.md`
</output>

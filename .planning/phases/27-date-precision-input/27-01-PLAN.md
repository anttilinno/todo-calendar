---
phase: 27-date-precision-input
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/store/todo.go
  - internal/store/iface.go
  - internal/store/sqlite.go
  - internal/store/sqlite_test.go
autonomous: true

must_haves:
  truths:
    - "Month-level todos stored with date_precision='month' and date='YYYY-MM-01'"
    - "Year-level todos stored with date_precision='year' and date='YYYY-01-01'"
    - "Day-level todos continue to work exactly as before with date_precision='day'"
    - "Existing day-level queries (IncompleteTodosPerDay, TotalTodosPerDay, TodosForMonth, TodosForDateRange) exclude fuzzy-date todos"
    - "New store methods return month-level and year-level todos for a given period"
  artifacts:
    - path: "internal/store/todo.go"
      provides: "Todo struct with DatePrecision field and precision helper methods"
      contains: "DatePrecision"
    - path: "internal/store/iface.go"
      provides: "TodoStore interface with precision-aware Add and query methods"
      contains: "MonthTodos"
    - path: "internal/store/sqlite.go"
      provides: "Migration 6 adding date_precision column, updated CRUD, new fuzzy queries"
      contains: "version < 6"
    - path: "internal/store/sqlite_test.go"
      provides: "Tests for date precision storage and querying"
      contains: "TestDatePrecision"
  key_links:
    - from: "internal/store/sqlite.go"
      to: "internal/store/todo.go"
      via: "scanTodo reads date_precision column"
      pattern: "DatePrecision"
    - from: "internal/store/sqlite.go"
      to: "internal/store/iface.go"
      via: "SQLiteStore implements new interface methods"
      pattern: "MonthTodos|YearTodos"
---

<objective>
Add date precision support to the storage layer so todos can be stored with day, month, or year granularity.

Purpose: Foundation for month-level and year-level todos (DATE-01, DATE-02). All later display and input work depends on the store correctly distinguishing precision levels.
Output: Updated store package with date_precision column, precision-aware CRUD, and new query methods.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/store/todo.go
@internal/store/iface.go
@internal/store/sqlite.go
@internal/store/sqlite_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add date_precision column and update Todo struct</name>
  <files>internal/store/todo.go, internal/store/sqlite.go</files>
  <action>
1. In `internal/store/todo.go`:
   - Add a `DatePrecision` field to the Todo struct: `DatePrecision string \`json:"date_precision"\`` (values: "day", "month", "year", or "" for floating)
   - Add helper methods:
     - `IsMonthPrecision() bool` returns `t.DatePrecision == "month"`
     - `IsYearPrecision() bool` returns `t.DatePrecision == "year"`
     - `IsFuzzy() bool` returns `t.DatePrecision == "month" || t.DatePrecision == "year"`
   - Update `InMonth()` to also match month-precision todos (date stored as "YYYY-MM-01", matches if year and month match) and year-precision todos (date stored as "YYYY-01-01", matches if year matches). Keep existing day-level matching unchanged.
   - Update `InDateRange()` to handle fuzzy dates: month-precision matches if any day in that month overlaps the range; year-precision matches if any day in that year overlaps the range. For the purposes of Phase 27, it is acceptable if fuzzy todos are excluded from InDateRange (weekly view excludes them per VIEW-01 requirement).

2. In `internal/store/sqlite.go`:
   - Add migration `version < 6`:
     ```sql
     ALTER TABLE todos ADD COLUMN date_precision TEXT NOT NULL DEFAULT 'day'
     ```
     Then update existing floating todos (date IS NULL) to have date_precision='':
     ```sql
     UPDATE todos SET date_precision = '' WHERE date IS NULL
     ```
     Set `PRAGMA user_version = 6`.
   - Update `todoColumns` to include `date_precision` (add after `schedule_date`).
   - Update `scanTodo()` to scan the new `date_precision` column into `t.DatePrecision`.
   - Update `Add()` method signature to accept `datePrecision string` as third parameter. When datePrecision is "" or "day", store as before. When "month", store date as "YYYY-MM-01" with date_precision="month". When "year", store date as "YYYY-01-01" with date_precision="year". Floating todos (date="") get date_precision="".
   - Update `Update()` method signature to accept `datePrecision string` as fourth parameter. Same logic as Add.
   - Update `AddScheduledTodo()` to always pass date_precision="day" (scheduled todos are always day-precision).
   - Update existing day-level query methods (`IncompleteTodosPerDay`, `TotalTodosPerDay`) to add `AND date_precision = 'day'` to their WHERE clauses so they exclude fuzzy todos from calendar bracket indicators.
   - Update `TodosForMonth()` to add `AND date_precision = 'day'` so it only returns day-precision todos for the month section (Phase 28 will add separate sections for fuzzy todos).
   - Update `TodosForDateRange()` to add `AND date_precision = 'day'` so weekly view excludes fuzzy todos (VIEW-01 requirement, implemented early at store level).
   - Add two new query methods:
     - `MonthTodos(year int, month time.Month) []Todo` -- returns todos where `date_precision = 'month'` and the date's year and month match. SQL: `WHERE date_precision = 'month' AND substr(date, 1, 7) = ?` with param formatted as "YYYY-MM".
     - `YearTodos(year int) []Todo` -- returns todos where `date_precision = 'year'` and the date's year matches. SQL: `WHERE date_precision = 'year' AND substr(date, 1, 4) = ?` with param formatted as "YYYY".
     Both return results ordered by `sort_order, id`.
  </action>
  <verify>
  `go build ./...` compiles successfully. Existing tests still pass: `go test ./internal/store/...`
  </verify>
  <done>
  Todo struct has DatePrecision field. Migration 6 adds date_precision column. Add/Update accept precision parameter. Day-level queries exclude fuzzy todos. MonthTodos and YearTodos methods exist and compile.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update TodoStore interface and callers, add tests</name>
  <files>internal/store/iface.go, internal/store/sqlite_test.go, internal/app/model.go, internal/todolist/model.go, internal/recurring/generate.go</files>
  <action>
1. In `internal/store/iface.go`:
   - Update `Add(text string, date string)` to `Add(text string, date string, datePrecision string) Todo`
   - Update `Update(id int, text string, date string)` to `Update(id int, text string, date string, datePrecision string)`
   - Add `MonthTodos(year int, month time.Month) []Todo`
   - Add `YearTodos(year int) []Todo`

2. Update all callers of `Add()` and `Update()` to pass the new datePrecision parameter:
   - `internal/todolist/model.go` `saveAdd()`: pass `"day"` for now (Phase 27 Plan 02 will compute precision from segmented input). If date is empty (floating), pass `""`.
   - `internal/todolist/model.go` `saveEdit()`: same -- pass `"day"` if date is non-empty, `""` if empty.
   - `internal/recurring/generate.go`: find where AddScheduledTodo is called -- it already uses a separate method, so no change needed. But check if there are any direct calls to `store.Add()` in the recurring package or elsewhere. Search with grep. If none, only todolist needs updating.
   - `internal/app/model.go`: no direct Add/Update calls (routes through todolist). No change needed.

3. In `internal/store/sqlite_test.go`:
   - Add `TestDatePrecision` test:
     - Create store, add a day-level todo: `s.Add("Day task", "2026-03-15", "day")` -- verify DatePrecision="day"
     - Add a month-level todo: `s.Add("Month task", "2026-03-01", "month")` -- verify DatePrecision="month" and Date="2026-03-01"
     - Add a year-level todo: `s.Add("Year task", "2026-01-01", "year")` -- verify DatePrecision="year" and Date="2026-01-01"
     - Add a floating todo: `s.Add("Float", "", "")` -- verify DatePrecision="" and Date=""
   - Add `TestMonthTodosQuery` test:
     - Add month-precision todo for March 2026, day-precision todo for March 15 2026
     - Call `MonthTodos(2026, time.March)` -- should return only the month-precision todo
     - Call `MonthTodos(2026, time.April)` -- should return empty
   - Add `TestYearTodosQuery` test:
     - Add year-precision todo for 2026, day-precision todo for 2026-03-15
     - Call `YearTodos(2026)` -- should return only the year-precision todo
     - Call `YearTodos(2027)` -- should return empty
   - Add `TestDayQueriesExcludeFuzzy` test:
     - Add day-level, month-level, and year-level todos all in March 2026
     - Call `TodosForMonth(2026, time.March)` -- should return only day-level todo
     - Call `IncompleteTodosPerDay(2026, time.March)` -- should count only day-level todo
     - Call `TotalTodosPerDay(2026, time.March)` -- should count only day-level todo
  </action>
  <verify>
  `go build ./...` compiles. `go test ./internal/store/... -v` passes all tests including the new ones. `go test ./...` passes everything.
  </verify>
  <done>
  TodoStore interface updated with precision parameters and new methods. All callers compile. New tests verify: precision stored correctly, MonthTodos/YearTodos return correct subsets, day-level queries exclude fuzzy todos.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles with zero errors
2. `go test ./internal/store/... -v` passes all existing and new tests
3. `go test ./...` passes all tests across the project
4. Verify migration: new SQLiteStore on fresh DB creates date_precision column (covered by tests using t.TempDir())
</verification>

<success_criteria>
- Todo struct has DatePrecision field with helper methods (IsFuzzy, IsMonthPrecision, IsYearPrecision)
- Migration 6 adds date_precision column with 'day' default
- Add() and Update() accept datePrecision parameter
- MonthTodos() and YearTodos() query methods return correct subsets
- Day-level queries (IncompleteTodosPerDay, TotalTodosPerDay, TodosForMonth, TodosForDateRange) exclude fuzzy-date todos
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/27-date-precision-input/27-01-SUMMARY.md`
</output>

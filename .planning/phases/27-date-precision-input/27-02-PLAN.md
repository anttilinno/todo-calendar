---
phase: 27-date-precision-input
plan: 02
type: execute
wave: 2
depends_on: ["27-01"]
files_modified:
  - internal/todolist/model.go
  - internal/todolist/styles.go
autonomous: true

must_haves:
  truths:
    - "Date input shows three separate segments (dd / mm / yyyy or reordered per config) instead of a single text field"
    - "Tab moves focus between segments within the date field; outer Tab cycles to the next form field"
    - "Leaving day segment blank but filling month+year creates a month-level todo"
    - "Leaving day+month segments blank but filling year creates a year-level todo"
    - "Segment order matches configured date format (ISO: yyyy mm dd, EU: dd mm yyyy, US: mm dd yyyy)"
    - "Existing day-level add/edit flow works identically (fill all 3 segments)"
  artifacts:
    - path: "internal/todolist/model.go"
      provides: "Segmented date input with 3 textinputs, precision derivation, format-aware ordering"
      contains: "dateSegDay"
    - path: "internal/todolist/styles.go"
      provides: "Styles for date segment separators and active segment highlight"
      contains: "DateSeparator"
  key_links:
    - from: "internal/todolist/model.go"
      to: "internal/store/iface.go"
      via: "saveAdd/saveEdit pass datePrecision derived from empty segments"
      pattern: "datePrecision"
    - from: "internal/todolist/model.go"
      to: "internal/config/config.go"
      via: "segment order derived from DateFormat config"
      pattern: "dateSegmentOrder"
---

<objective>
Replace the single date text input with a 3-segment date field (dd/mm/yyyy) that supports Tab navigation between segments and derives date precision from which segments are filled.

Purpose: Users can create month-level or year-level todos by leaving segments blank (DATE-01 through DATE-04). The segmented input also improves the date entry experience by eliminating typed separators.
Output: Updated todolist model with segmented date input, format-aware segment ordering, and precision-aware save logic.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-date-precision-input/27-01-SUMMARY.md
@internal/todolist/model.go
@internal/todolist/styles.go
@internal/config/config.go
@internal/store/iface.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement segmented date input with format-aware ordering</name>
  <files>internal/todolist/model.go, internal/todolist/styles.go</files>
  <action>
1. In `internal/todolist/model.go`, replace the single `dateInput textinput.Model` with three segment inputs:

   Add new fields to Model struct:
   ```go
   // Segmented date input (replaces dateInput)
   dateSegDay    textinput.Model
   dateSegMonth  textinput.Model
   dateSegYear   textinput.Model
   dateSegFocus  int    // 0, 1, 2 = which segment is focused (left to right)
   dateSegOrder  [3]int // maps visual position to semantic: 0=day, 1=month, 2=year
   ```

   Remove the old `dateInput textinput.Model` field entirely.

   In `New()`:
   - Create three textinput models:
     - `dateSegDay`: Placeholder "dd", CharLimit 2, Width 4, Prompt ""
     - `dateSegMonth`: Placeholder "mm", CharLimit 2, Width 4, Prompt ""
     - `dateSegYear`: Placeholder "yyyy", CharLimit 4, Width 6, Prompt ""
   - Set initial `dateSegOrder` based on the default date format (ISO: [2,1,0] meaning year-month-day left to right; EU: [0,1,2] for day-month-year; US: [1,0,2] for month-day-year). Use a helper function `dateSegmentOrder(dateFormat string) [3]int` that returns the visual-to-semantic mapping.
   - Remove the old `dateInput` initialization.

   Add helper function `dateSegmentOrder(dateFormat string) [3]int`:
   ```go
   func dateSegmentOrder(format string) [3]int {
       switch format {
       case "eu":
           return [3]int{0, 1, 2} // dd mm yyyy
       case "us":
           return [3]int{1, 0, 2} // mm dd yyyy
       default: // iso
           return [3]int{2, 1, 0} // yyyy mm dd
       }
   }
   ```

   Add helper method `dateSegmentByPos(pos int) *textinput.Model` that returns the textinput for a visual position using dateSegOrder:
   ```go
   func (m *Model) dateSegmentByPos(pos int) *textinput.Model {
       switch m.dateSegOrder[pos] {
       case 0: return &m.dateSegDay
       case 1: return &m.dateSegMonth
       case 2: return &m.dateSegYear
       default: return &m.dateSegDay
       }
   }
   ```

   Add helper method `dateSegSeparator() string` that returns the separator character for the configured format: ISO returns "-", EU returns ".", US returns "/".

   In `SetDateFormat()`, also update `dateSegOrder` based on the format name. Add a `dateFormat string` field to Model to store "iso"/"eu"/"us". Update `SetDateFormat` signature to: `SetDateFormat(format, layout, placeholder string)`. Store format in `m.dateFormat`, compute `m.dateSegOrder = dateSegmentOrder(format)`. Update the caller in `app/model.go` to pass `m.cfg.DateFormat` as the first arg.

2. Update the form field cycling (Tab behavior):

   The date field is now `editField == 1`. Within editField 1, Tab first cycles between the 3 date segments (dateSegFocus 0 -> 1 -> 2). After the last segment, Tab moves to the next form field (body, editField 2).

   In `updateInputMode` for `key.Matches(msg, m.keys.SwitchField)`:
   - When `editField == 0` (title): move to editField 1, dateSegFocus 0, focus the first segment.
   - When `editField == 1` (date):
     - If `dateSegFocus < 2`: increment dateSegFocus, blur current segment, focus next segment.
     - If `dateSegFocus == 2`: move to editField 2 (body), blur all date segments.
   - When `editField == 2` (body): move to editField 3 (template).
   - When `editField == 3` (template): move to editField 0 (title).

   Same pattern in `updateEditMode` for Tab, except edit mode has no template field:
   - `editField == 0` -> `editField 1, dateSegFocus 0`
   - `editField == 1`: cycle segments, then `editField 2`
   - `editField == 2` -> `editField 0`

   For Shift+Tab or backward movement: not needed (existing behavior is forward-only Tab cycling, keep that).

3. Update blink/tick forwarding (the non-key-msg routing in Update):
   When `editField == 1`, forward blink messages to the currently focused date segment using `dateSegmentByPos(dateSegFocus)`.

4. Update key forwarding in `updateInputMode` and `updateEditMode`:
   When `editField == 1`, forward key events to the focused date segment. But intercept certain keys:
   - Number keys: forward to focused segment. If the segment reaches its CharLimit (2 for day/month, 4 for year), auto-advance to the next segment (increment dateSegFocus and focus). This makes typing "15032026" naturally flow through dd-mm-yyyy.
   - Backspace on empty segment: move focus back to previous segment (if dateSegFocus > 0).
   - Do NOT forward separator characters (-, ., /) -- they are visual only in segmented mode.

5. Update `saveAdd()`:
   - Read values from the three segments: `day := m.dateSegDay.Value()`, `month := m.dateSegMonth.Value()`, `year := m.dateSegYear.Value()`
   - Derive precision and ISO date:
     - If year == "": floating todo (no date). Pass `store.Add(text, "", "")`.
     - If year != "" && month == "" && day == "": year-precision. Pass `store.Add(text, year+"-01-01", "year")`.
     - If year != "" && month != "" && day == "": month-precision. Pad month to 2 digits. Pass `store.Add(text, year+"-"+paddedMonth+"-01", "month")`.
     - If year != "" && month != "" && day != "": day-precision. Validate as a real date using time.Parse. Pass `store.Add(text, isoDate, "day")`.
     - If partial invalid combo (e.g., day filled but no month): focus the missing segment and return without saving.
   - Validate year is 4 digits, month is 1-12, day is valid for the month.

6. Update `saveEdit()`:
   - Same precision derivation logic as saveAdd.
   - Call `store.Update(id, text, isoDate, datePrecision)`.

7. Update `editView()` rendering:
   - Instead of rendering `m.dateInput.View()`, render the three segments with separators:
     ```
     Date
     [dd] . [mm] . [yyyy]    (EU format)
     [yyyy] - [mm] - [dd]    (ISO format)
     [mm] / [dd] / [yyyy]    (US format)
     ```
   - Use the dateSegOrder to render segments in the correct visual order.
   - The focused segment should be visually distinct (the textinput.Model handles cursor/blink when focused).
   - Render separator characters between segments using a muted style.
   - Show hint text below: "(leave day blank for month todo, leave day+month blank for year todo)"

8. Update the "Edit" mode entry (`key.Matches(msg, m.keys.Edit)`):
   - When populating from an existing todo, parse the ISO date back into segments:
     - If DatePrecision == "day": split "YYYY-MM-DD" into segments, respecting display format. Set all three segment values.
     - If DatePrecision == "month": set year and month segments, leave day blank.
     - If DatePrecision == "year": set year segment only, leave day and month blank.
     - If floating (no date): leave all segments blank.
   - Set dateSegFocus = 0 (first visual segment).

9. Update the Add mode entry (`key.Matches(msg, m.keys.Add)`):
   - Clear all three date segments: `dateSegDay.SetValue("")`, `dateSegMonth.SetValue("")`, `dateSegYear.SetValue("")`.
   - Set dateSegFocus = 0.

10. Update cancel handlers in both input and edit modes to clear all three segments and reset dateSegFocus.

11. Update `renderTodo()` to display fuzzy dates appropriately:
    - Day-precision: show formatted date as before (e.g., "2026-03-15" or "15.03.2026").
    - Month-precision: show only month and year (e.g., "March 2026" or "2026-03" depending on format -- use month name + year for clarity).
    - Year-precision: show only year (e.g., "2026").

12. In `internal/todolist/styles.go`, add a `DateSeparator` style (MutedFg color) for rendering the separator characters between date segments.

13. In `internal/app/model.go`:
    - Update the call to `tl.SetDateFormat(cfg.DateLayout(), cfg.DatePlaceholder())` to `tl.SetDateFormat(cfg.DateFormat, cfg.DateLayout(), cfg.DatePlaceholder())`.
    - Same update in the settings save handler.
  </action>
  <verify>
  `go build ./...` compiles with zero errors. `go test ./...` passes all tests. Manual smoke test: run the app, press `a` to add, verify 3 date segments appear in correct order for configured format, Tab moves between segments, filling only year creates year-level todo, filling year+month creates month-level todo, filling all three creates day-level todo.
  </verify>
  <done>
  Date input shows 3 segments in format-aware order. Tab navigates between segments. Empty segments derive correct date precision. saveAdd/saveEdit pass precision to store. renderTodo shows appropriate date format for each precision level. Existing day-level workflow unchanged.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles with zero errors
2. `go test ./...` passes all tests
3. Segmented date field renders with correct segment order per format setting
4. Tab cycles through segments within date field, then advances to next form field
5. Adding a todo with only year filled creates a year-precision todo
6. Adding a todo with year+month filled creates a month-precision todo
7. Adding a todo with all segments filled creates a day-precision todo
8. Editing a fuzzy-date todo pre-populates only the relevant segments
9. Fuzzy-date todos display with appropriate formatting in the todo list
</verification>

<success_criteria>
- Segmented date input with 3 fields (dd, mm, yyyy) replaces single date text input
- Segment order matches configured date format (ISO/EU/US)
- Tab navigates between segments within date field
- Empty segments correctly derive month or year date precision
- Day-precision add/edit works identically to before
- Fuzzy dates display as "March 2026" (month) or "2026" (year) in todo list
- All existing tests pass, app compiles
</success_criteria>

<output>
After completion, create `.planning/phases/27-date-precision-input/27-02-SUMMARY.md`
</output>

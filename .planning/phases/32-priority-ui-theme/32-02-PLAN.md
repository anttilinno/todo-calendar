---
phase: 32-priority-ui-theme
plan: 02
type: execute
wave: 2
depends_on: ["32-01"]
files_modified:
  - internal/calendar/styles.go
  - internal/calendar/grid.go
  - internal/calendar/model.go
  - internal/search/styles.go
  - internal/search/model.go
autonomous: true

must_haves:
  truths:
    - "Calendar day indicators reflect the highest-priority incomplete todo's color for that day"
    - "Days with only non-prioritized incomplete todos use the existing default indicator color"
    - "Search results display priority badges matching the todo list rendering"
  artifacts:
    - path: "internal/calendar/styles.go"
      provides: "IndicatorP1-P4 and TodayIndicatorP1-P4 styles"
      contains: "IndicatorP1"
    - path: "internal/calendar/grid.go"
      provides: "Priority-aware indicator coloring in both RenderGrid and RenderWeekGrid"
      contains: "HighestPriorityPerDay"
    - path: "internal/calendar/model.go"
      provides: "priorities map[int]int field, refreshed alongside indicators"
      contains: "priorities"
    - path: "internal/search/styles.go"
      provides: "PriorityP1-P4 badge styles"
      contains: "PriorityP1"
    - path: "internal/search/model.go"
      provides: "Priority badge rendering in search result lines"
      contains: "HasPriority"
  key_links:
    - from: "internal/calendar/grid.go"
      to: "internal/store/iface.go"
      via: "RenderGrid receives priorities map from HighestPriorityPerDay"
      pattern: "priorities\\[day\\]"
    - from: "internal/calendar/model.go"
      to: "internal/store/iface.go"
      via: "RefreshIndicators calls HighestPriorityPerDay"
      pattern: "HighestPriorityPerDay"
    - from: "internal/search/model.go"
      to: "internal/search/styles.go"
      via: "View uses priorityBadgeStyle for badge rendering"
      pattern: "priorityBadgeStyle"
---

<objective>
Add priority-aware calendar day indicators and priority badges in search results.

Purpose: Complete the priority visual system across all views. PRIO-05 (calendar + search styles), PRIO-06 (calendar indicators), PRIO-07 (search badges).
Output: Calendar day brackets colored by highest-priority incomplete todo. Search results display same priority badge as todo list.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-priority-ui-theme/32-RESEARCH.md
@.planning/phases/32-priority-ui-theme/32-01-SUMMARY.md
@internal/calendar/styles.go
@internal/calendar/grid.go
@internal/calendar/model.go
@internal/search/styles.go
@internal/search/model.go
@internal/theme/theme.go
@internal/store/iface.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Calendar priority-aware indicator styles and grid rendering</name>
  <files>internal/calendar/styles.go, internal/calendar/grid.go, internal/calendar/model.go</files>
  <action>
1. **internal/calendar/styles.go** -- Add 8 new styles to the Styles struct for priority-colored indicators:
   ```go
   IndicatorP1      lipgloss.Style  // P1 priority pending indicator
   IndicatorP2      lipgloss.Style  // P2 priority pending indicator
   IndicatorP3      lipgloss.Style  // P3 priority pending indicator
   IndicatorP4      lipgloss.Style  // P4 priority pending indicator
   TodayIndicatorP1 lipgloss.Style  // P1 on today's date
   TodayIndicatorP2 lipgloss.Style  // P2 on today's date
   TodayIndicatorP3 lipgloss.Style  // P3 on today's date
   TodayIndicatorP4 lipgloss.Style  // P4 on today's date
   ```
   In NewStyles, initialize them following the existing pattern:
   - `IndicatorP*`: `lipgloss.NewStyle().Bold(true).Foreground(t.PriorityP*Fg)` (same pattern as existing Indicator but with priority colors)
   - `TodayIndicatorP*`: `lipgloss.NewStyle().Bold(true).Foreground(t.PriorityP*Fg).Background(t.TodayBg)` (same pattern as existing TodayIndicator but with priority colors)

2. **internal/calendar/model.go** -- Add `priorities map[int]int` field to the Model struct (alongside existing `indicators` and `totals`).
   - In `New()`: initialize `priorities: s.HighestPriorityPerDay(y, m)` alongside existing indicators/totals initialization.
   - In `RefreshIndicators()`: add `m.priorities = m.store.HighestPriorityPerDay(m.year, m.month)` alongside existing indicator/totals refresh.
   - In `Update()` for PrevMonth/NextMonth/ToggleWeek: add `m.priorities = m.store.HighestPriorityPerDay(m.year, m.month)` alongside existing indicator/totals updates (there are 3 places: ToggleWeek, PrevMonth, NextMonth).
   - In `SetYearMonth()`: add `m.priorities = m.store.HighestPriorityPerDay(year, month)` alongside existing.
   - In `View()` for month view: pass `m.priorities` to RenderGrid as a new parameter.
   - In `View()` for week view: RenderWeekGrid already has access to the store, so pass priorities through in the same way (see grid.go changes below).

3. **internal/calendar/grid.go** -- Modify both RenderGrid and RenderWeekGrid to use priority-graded indicator colors.

   **RenderGrid changes:**
   - Add `priorities map[int]int` parameter to the function signature (after `totals`):
     ```go
     func RenderGrid(year int, month time.Month, today int, holidays map[int]bool, mondayStart bool, indicators map[int]int, totals map[int]int, priorities map[int]int, st store.TodoStore, ...) string
     ```
   - In the day cell styling switch, replace the `case hasPending:` branch with priority-aware logic:
     ```go
     case day == today && hasPending:
         prio := priorities[day]
         switch prio {
         case 1: cell = s.TodayIndicatorP1.Render(cell)
         case 2: cell = s.TodayIndicatorP2.Render(cell)
         case 3: cell = s.TodayIndicatorP3.Render(cell)
         case 4: cell = s.TodayIndicatorP4.Render(cell)
         default: cell = s.TodayIndicator.Render(cell) // no prioritized todo, use default
         }
     ```
     And the non-today pending case:
     ```go
     case hasPending:
         prio := priorities[day]
         switch prio {
         case 1: cell = s.IndicatorP1.Render(cell)
         case 2: cell = s.IndicatorP2.Render(cell)
         case 3: cell = s.IndicatorP3.Render(cell)
         case 4: cell = s.IndicatorP4.Render(cell)
         default: cell = s.Indicator.Render(cell) // no prioritized todo, use default
         }
     ```
   - Update the caller in calendar/model.go View() to pass m.priorities.

   **RenderWeekGrid changes:**
   - Add `priorities` parameter. However, since RenderWeekGrid spans potentially 2 months, priorities need to be looked up per-day's month. Add a `priorityCache` similar to the existing `indicatorCache`:
     ```go
     priorityCache := make(map[monthKey]map[int]int)
     getPriorities := func(y int, m time.Month) map[int]int {
         k := monthKey{y, m}
         if v, ok := priorityCache[k]; ok { return v }
         v := st.HighestPriorityPerDay(y, m)
         priorityCache[k] = v
         return v
     }
     ```
   - In the day cell styling switch, replace both `case isToday && hasPending:` and `case hasPending:` with priority-aware logic (same pattern as RenderGrid but using `getPriorities(dy, dm)[dd]`).
   - The function signature does NOT need a priorities parameter since it queries the store directly (same pattern as existing indicators/totals in RenderWeekGrid). No signature change needed for RenderWeekGrid.
  </action>
  <verify>
Run `go vet ./...` -- must pass (all callers of RenderGrid updated with new parameter).
Run `go test ./...` -- all tests must pass.
  </verify>
  <done>Calendar day indicators are colored by the highest-priority incomplete todo for that day. Days with P1 todos show red brackets, P2 orange, P3 blue, P4 grey. Days with only non-prioritized pending todos use the existing default indicator color. Today+priority combinations use the blended Today+Priority styles. Both monthly and weekly grid views are priority-aware.</done>
</task>

<task type="auto">
  <name>Task 2: Search results priority badge rendering</name>
  <files>internal/search/styles.go, internal/search/model.go</files>
  <action>
1. **internal/search/styles.go** -- Add priority badge styles to the Styles struct:
   ```go
   PriorityP1 lipgloss.Style
   PriorityP2 lipgloss.Style
   PriorityP3 lipgloss.Style
   PriorityP4 lipgloss.Style
   ```
   In NewStyles, initialize each as `lipgloss.NewStyle().Bold(true).Foreground(t.PriorityP*Fg)` (same as todolist styles).
   Add a helper method `func (s Styles) priorityBadgeStyle(level int) lipgloss.Style` with a switch on level 1-4, default returns PriorityP4 (same pattern as todolist).

2. **internal/search/model.go** -- Add priority badge rendering in the View() method's result loop.
   In the result rendering loop (where it builds `"> %s %s"` or `"  %s %s"` lines), insert a fixed-width 5-char priority badge slot between the cursor/indent and the checkbox:

   Before the existing check/line formatting, build the badge string:
   ```go
   // Priority badge (PRIO-07) -- fixed-width 5-char slot
   var badge string
   if r.HasPriority() {
       label := fmt.Sprintf("[%s]", r.PriorityLabel())
       badge = m.styles.priorityBadgeStyle(r.Priority).Render(label) + " "
   } else {
       badge = "     " // 5 spaces for alignment
   }
   ```

   Then modify the line formatting:
   - Selected: `line := fmt.Sprintf("> %s%s %s", badge, check, r.Text)` -- note badge is BEFORE checkbox to match todolist rendering order. Actually, check the rendering order from Plan 01: in todolist it's cursor > badge > checkbox > text. So for search:
     ```go
     if i == m.cursor {
         cursor := "> "
         b.WriteString(m.styles.SelectedResult.Render(cursor))
         b.WriteString(badge)
         b.WriteString(m.styles.SelectedResult.Render(check + " " + r.Text))
         b.WriteString("  ")
         b.WriteString(m.styles.SelectedDate.Render(dateStr))
     } else {
         b.WriteString("  ")
         b.WriteString(badge)
         b.WriteString(m.styles.ResultText.Render(check + " " + r.Text))
         b.WriteString("  ")
         b.WriteString(m.styles.ResultDate.Render(dateStr))
     }
     ```

   For completed todos in search results: the badge keeps its priority color (badge is rendered with priorityBadgeStyle regardless of r.Done). The result text styling (SelectedResult or ResultText) does not apply strikethrough -- search results currently don't distinguish completed visually in the text style, only via the [x] checkbox. This is consistent with existing behavior; adding strikethrough to search is out of scope.

   Import `fmt` is already imported. `r.HasPriority()` and `r.PriorityLabel()` are methods on store.Todo (added in Phase 31).
  </action>
  <verify>
Run `go vet ./...` -- must pass.
Run `go test ./...` -- all tests must pass.
  </verify>
  <done>Search results show colored [P1]-[P4] badge prefix with fixed 5-char slot, matching the todo list rendering order (cursor > badge > checkbox > text). Non-prioritized search results have 5 spaces for alignment. Priority badge colors come from the theme.</done>
</task>

</tasks>

<verification>
- `go vet ./...` passes
- `go test ./...` passes
- Calendar monthly view shows priority-colored brackets for days with prioritized incomplete todos
- Calendar weekly view shows priority-colored brackets for days with prioritized incomplete todos
- Days with no prioritized todos but pending todos still show default indicator color
- Search results display [P1]-[P4] badges with consistent alignment
- All 4 themes have correct priority indicator styles in both calendar and search
</verification>

<success_criteria>
1. `go vet ./...` and `go test ./...` pass cleanly
2. Calendar day indicators colored by highest-priority incomplete todo (P1=red, P2=orange, P3=blue, P4=grey)
3. Default indicator color preserved for non-prioritized pending days
4. Today+priority blended styles work correctly
5. Both monthly and weekly grid views are priority-aware
6. Search results show priority badges with same visual pattern as todo list
7. Badge alignment consistent in search (5-char fixed-width slot)
</success_criteria>

<output>
After completion, create `.planning/phases/32-priority-ui-theme/32-02-SUMMARY.md`
</output>

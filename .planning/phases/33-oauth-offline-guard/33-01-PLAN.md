---
phase: 33-oauth-offline-guard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/google/auth.go
  - internal/google/auth_test.go
  - go.mod
  - go.sum
autonomous: true
user_setup:
  - service: google-cloud
    why: "OAuth 2.0 credentials for Google Calendar API"
    env_vars: []
    dashboard_config:
      - task: "Create GCP project, enable Calendar API, create OAuth 2.0 Desktop client, download credentials.json to ~/.config/todo-calendar/credentials.json"
        location: "Google Cloud Console -> APIs & Services -> Credentials"

must_haves:
  truths:
    - "OAuth config loads from credentials.json in config dir"
    - "Token persists as JSON at google-token.json with 0600 permissions"
    - "Token auto-refreshes and persisted token updates on refresh"
    - "Auth state is correctly detected (NotConfigured, NeedsLogin, Ready)"
    - "Auth flow opens browser, receives callback on loopback, exchanges code for token"
    - "App does not error when credentials.json is absent"
  artifacts:
    - path: "internal/google/auth.go"
      provides: "OAuth config, token persistence, auth flow, AuthState, AuthResultMsg"
      exports: ["AuthState", "AuthNotConfigured", "AuthNeedsLogin", "AuthReady", "AuthRevoked", "AuthResultMsg", "CheckAuthState", "StartAuthFlow", "TokenSource"]
    - path: "internal/google/auth_test.go"
      provides: "Unit tests for token persistence, config loading, auth state detection"
      contains: "func Test"
  key_links:
    - from: "internal/google/auth.go"
      to: "golang.org/x/oauth2"
      via: "oauth2.Config, oauth2.Token, oauth2.TokenSource"
      pattern: "oauth2\\."
    - from: "internal/google/auth.go"
      to: "~/.config/todo-calendar/credentials.json"
      via: "google.ConfigFromJSON"
      pattern: "ConfigFromJSON"
    - from: "internal/google/auth.go"
      to: "~/.config/todo-calendar/google-token.json"
      via: "saveToken/loadToken"
      pattern: "google-token\\.json"
---

<objective>
Create the `internal/google` package with OAuth 2.0 authentication core: credential loading, loopback auth flow with PKCE, token persistence with 0600 permissions, transparent token refresh via persistingTokenSource, auth state detection, and Bubble Tea integration via AuthResultMsg.

Purpose: This is the foundation for Google Calendar integration. All auth logic lives in one focused package that Phase 34 will import for authenticated HTTP clients.
Output: `internal/google/auth.go` + `internal/google/auth_test.go`, `golang.org/x/oauth2` dependency added.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-oauth-offline-guard/33-RESEARCH.md
@internal/config/paths.go
@internal/config/config.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create internal/google/auth.go with OAuth core</name>
  <files>internal/google/auth.go, go.mod, go.sum</files>
  <action>
Run `go get golang.org/x/oauth2` to add the dependency.

Create `internal/google/auth.go` in package `google` with:

1. **Path helpers** — `CredentialsPath()` and `TokenPath()` returning `(string, error)`. Use `os.UserConfigDir()` + `"todo-calendar"` subfolder, matching `internal/config/paths.go` pattern. Credentials file: `credentials.json`. Token file: `google-token.json`.

2. **AuthState enum** — `AuthState int` with constants: `AuthNotConfigured` (no credentials.json), `AuthNeedsLogin` (credentials exist but no token), `AuthReady` (token exists), `AuthRevoked` (token exists but refresh fails). Export all.

3. **CheckAuthState() AuthState** — Check credentials.json exists (stat), then check google-token.json exists (stat). Return appropriate state. No network calls.

4. **loadConfig(credPath string) (*oauth2.Config, error)** — Read credentials.json, call `google.ConfigFromJSON(b, "https://www.googleapis.com/auth/calendar.events.readonly")`. RedirectURL left empty (set dynamically by auth flow).

5. **Token persistence** — `saveToken(path string, tok *oauth2.Token) error` using atomic write: `os.CreateTemp` in same dir, write JSON, `Sync`, `Close`, `os.Chmod(tmpName, 0600)`, `os.Rename(tmpName, path)`. Follow the exact pattern from `config.Save()`. `loadToken(path string) (*oauth2.Token, error)` reads and decodes JSON.

6. **persistingTokenSource** — Struct wrapping `oauth2.TokenSource` with `path string`, `mu sync.Mutex`, `lastHash string`. `Token()` method calls inner source, compares hash (`AccessToken + Expiry.String()`), saves if changed. Implements `oauth2.TokenSource`.

7. **TokenSource() (oauth2.TokenSource, error)** — Public function. Loads config from CredentialsPath, loads token from TokenPath. If either missing, returns nil + descriptive error. Creates `oauth2.Config.TokenSource(ctx, tok)` wrapped in `persistingTokenSource`. This is what Phase 34 will call to get an authenticated HTTP client.

8. **performAuthFlow(ctx context.Context, cfg *oauth2.Config) (*oauth2.Token, error)** — Internal function:
   - Listen on `127.0.0.1:0` (ephemeral port)
   - Set `cfg.RedirectURL = fmt.Sprintf("http://127.0.0.1:%d/callback", port)`
   - Generate PKCE verifier via `oauth2.GenerateVerifier()`
   - Build auth URL with `oauth2.AccessTypeOffline`, `oauth2.S256ChallengeOption(verifier)`, `oauth2.SetAuthURLParam("prompt", "consent")`
   - Open browser: check `DISPLAY`/`WAYLAND_DISPLAY` env vars, use `xdg-open` if available, otherwise return error with the URL for manual copy
   - HTTP handler on `/callback` extracts `code` param, writes success HTML response, sends code on channel
   - `context.WithTimeout` of 2 minutes wrapping the wait
   - Exchange code via `cfg.Exchange(ctx, code, oauth2.VerifierOption(verifier))`
   - `defer srv.Shutdown(ctx)` to clean up

9. **AuthResultMsg** — `struct { Success bool; Err error }`. Exported for Bubble Tea message matching.

10. **StartAuthFlow() tea.Cmd** — Returns a `func() tea.Msg` that: loads config from CredentialsPath, calls `performAuthFlow`, saves token via `saveToken`, returns `AuthResultMsg`. Uses `context.Background()` with 2-minute timeout.

Import `tea "github.com/charmbracelet/bubbletea"` for the Cmd/Msg types. Import `"golang.org/x/oauth2"` and `"golang.org/x/oauth2/google"`.
  </action>
  <verify>
`cd /home/antti/Repos/Misc/todo-calendar && go build ./internal/google/` compiles without errors.
  </verify>
  <done>
internal/google/auth.go exists with all exported symbols: AuthState constants, CheckAuthState, TokenSource, StartAuthFlow, AuthResultMsg. Package compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for token persistence and auth state</name>
  <files>internal/google/auth_test.go</files>
  <action>
Create `internal/google/auth_test.go` in package `google` (not `google_test` — needs access to unexported helpers).

Tests:

1. **TestSaveLoadToken** — Create temp dir, call `saveToken` with a fabricated `oauth2.Token` (AccessToken, RefreshToken, TokenType, Expiry). Read it back with `loadToken`. Assert all fields match. Check file permissions are 0600 via `os.Stat().Mode().Perm()`.

2. **TestSaveTokenAtomicDir** — Save token to a path whose parent dir does not exist. Verify `saveToken` creates the directory (via `os.MkdirAll` in the function).

3. **TestCheckAuthState_NotConfigured** — Use temp dir. Override paths (pass paths directly or use helper). When neither credentials nor token exist, state should be `AuthNotConfigured`.

4. **TestCheckAuthState_NeedsLogin** — Create a dummy credentials.json in temp dir. No token file. State should be `AuthNeedsLogin`.

5. **TestCheckAuthState_Ready** — Create both credentials.json and google-token.json in temp dir. State should be `AuthReady`.

6. **TestLoadConfig_InvalidJSON** — Write invalid JSON to a temp file, call `loadConfig`. Assert error is returned.

Note: To make CheckAuthState testable with temp dirs, add an unexported `checkAuthStateAt(credPath, tokPath string) AuthState` that CheckAuthState delegates to. Tests call `checkAuthStateAt` directly with temp paths.

Similarly, make `loadConfig` accept a path parameter (it already does per the design).
  </action>
  <verify>
`cd /home/antti/Repos/Misc/todo-calendar && go test ./internal/google/ -v` — all tests pass.
  </verify>
  <done>
6+ tests pass covering token save/load round-trip, file permissions, auth state detection for all 3 states, and invalid config handling.
  </done>
</task>

</tasks>

<verification>
- `go build ./...` compiles the entire project including the new package
- `go test ./internal/google/ -v` — all tests pass
- `go vet ./internal/google/` — no warnings
- New package exports: AuthState, AuthNotConfigured, AuthNeedsLogin, AuthReady, AuthRevoked, AuthResultMsg, CheckAuthState, TokenSource, StartAuthFlow
</verification>

<success_criteria>
- internal/google/auth.go exists with complete OAuth implementation
- Token persistence uses atomic writes with 0600 permissions
- Auth state detection works without network calls
- Unit tests verify persistence, permissions, and state detection
- Package compiles and tests pass
- golang.org/x/oauth2 added to go.mod
</success_criteria>

<output>
After completion, create `.planning/phases/33-oauth-offline-guard/33-01-SUMMARY.md`
</output>

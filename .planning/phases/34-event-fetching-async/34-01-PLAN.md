---
phase: 34-event-fetching-async
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/google/events.go
  - internal/google/events_test.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "CalendarEvent struct decouples app from Google API types"
    - "FetchEvents handles full sync (timeMin/timeMax) and delta sync (syncToken)"
    - "410 GONE triggers automatic retry with full sync"
    - "All-day events store date as plain YYYY-MM-DD string without timezone conversion"
    - "Recurring events expanded server-side via SingleEvents(true)"
    - "Pagination handles calendars with >2500 events"
  artifacts:
    - path: "internal/google/events.go"
      provides: "CalendarEvent type, NewCalendarService, FetchEvents, FetchEventsCmd, EventsFetchedMsg, eventTickMsg"
      min_lines: 80
    - path: "internal/google/events_test.go"
      provides: "Unit tests for convertEvent (all-day and timed events)"
      min_lines: 30
  key_links:
    - from: "internal/google/events.go"
      to: "internal/google/auth.go"
      via: "TokenSource() called in NewCalendarService"
      pattern: "TokenSource\\(\\)"
    - from: "internal/google/events.go"
      to: "google.golang.org/api/calendar/v3"
      via: "Events.List API call"
      pattern: "calendar\\.NewService"
---

<objective>
Create the Google Calendar event fetching package with CalendarEvent type, API client, syncToken-based delta sync, and Bubble Tea command wrappers.

Purpose: Provide the data layer that fetches, converts, and exposes Google Calendar events for the TUI. This is the foundation for displaying events in Phase 35.
Output: `internal/google/events.go` with all fetch logic, `internal/google/events_test.go` with conversion tests.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-event-fetching-async/34-RESEARCH.md
@internal/google/auth.go
@internal/google/auth_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create events.go with CalendarEvent type, fetch logic, and Bubble Tea commands</name>
  <files>internal/google/events.go, go.mod, go.sum</files>
  <action>
Create `internal/google/events.go` in the existing `google` package with:

1. **CalendarEvent struct** — decoupled from Google API types:
   ```go
   type CalendarEvent struct {
       ID      string
       Summary string
       Date    string    // "2006-01-02" for ALL events (used as lookup key)
       Start   time.Time // parsed RFC3339 for timed events; zero for all-day
       End     time.Time // parsed RFC3339 for timed events; zero for all-day
       AllDay  bool
       Status  string    // "confirmed", "tentative", "cancelled"
   }
   ```

2. **NewCalendarService()** — creates `*calendar.Service` using `TokenSource()` from auth.go:
   ```go
   func NewCalendarService() (*calendar.Service, error)
   ```
   Uses `option.WithTokenSource(ts)`. Returns error if TokenSource fails.

3. **FetchEvents(srv *calendar.Service, syncToken string) ([]CalendarEvent, string, error)** — core fetch function:
   - If syncToken == "": full sync with `TimeMin(now - 1 month)`, `TimeMax(now + 3 months)`, `OrderBy("startTime")`
   - If syncToken != "": delta sync with `SyncToken(syncToken)` only (NO timeMin/timeMax/orderBy — API returns 400)
   - Always: `SingleEvents(true)`, `ShowDeleted(true)`, `MaxResults(2500)`
   - Pagination: loop until `NextPageToken` is empty, collect `NextSyncToken` from final page
   - 410 GONE handling: if `googleapi.Error` with Code 410, recursively call `FetchEvents(srv, "")` to retry full sync
   - Convert each `*calendar.Event` via `convertEvent()`
   - Use `context.WithTimeout(context.Background(), 30*time.Second)` for the API calls

4. **convertEvent(e *calendar.Event) CalendarEvent** — conversion function:
   - All-day: `e.Start.Date != ""` → set `AllDay=true`, `Date = e.Start.Date` (raw string, NO time.Parse)
   - Timed: `e.Start.DateTime != ""` → parse RFC3339 into Start/End, derive `Date` from `t.Format("2006-01-02")`
   - Copy ID, Summary, Status

5. **Bubble Tea message types and commands:**
   ```go
   type EventsFetchedMsg struct {
       Events    []CalendarEvent
       SyncToken string
       Err       error
   }
   type EventTickMsg time.Time

   func FetchEventsCmd(srv *calendar.Service, syncToken string) tea.Cmd
   func ScheduleEventTick() tea.Cmd  // tea.Tick(5*time.Minute, ...)
   ```
   `FetchEventsCmd` wraps `FetchEvents` in a `tea.Cmd` (runs in goroutine, returns `EventsFetchedMsg`).
   `ScheduleEventTick` returns `tea.Tick(5*time.Minute, func(t time.Time) tea.Msg { return EventTickMsg(t) })`.

6. **MergeEvents(existing []CalendarEvent, delta []CalendarEvent) []CalendarEvent** — incremental merge:
   - Build map by ID from existing events
   - For each delta event: if Status == "cancelled" → delete from map; otherwise → upsert
   - Return sorted slice (by Date, then Start time)

Run `go get google.golang.org/api/calendar/v3 google.golang.org/api/option` to add the dependency.
Run `go mod tidy` after creating the file.

IMPORTANT: Export FetchEventsCmd, ScheduleEventTick, EventsFetchedMsg, EventTickMsg, MergeEvents, CalendarEvent, NewCalendarService — these are consumed by the app model in Plan 02.
  </action>
  <verify>
Run `go build ./internal/google/...` — must compile without errors.
Run `go vet ./internal/google/...` — no warnings.
  </verify>
  <done>events.go exists with all exported types and functions. Package compiles. google.golang.org/api added to go.mod.</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for event conversion logic</name>
  <files>internal/google/events_test.go</files>
  <action>
Create `internal/google/events_test.go` with tests for `convertEvent` and `MergeEvents`:

1. **TestConvertEvent_AllDay** — create a `calendar.Event` with `Start.Date = "2026-02-14"`, `End.Date = "2026-02-15"`, verify:
   - `AllDay == true`
   - `Date == "2026-02-14"` (exact string, not parsed)
   - `Start.IsZero() == true`
   - `End.IsZero() == true`

2. **TestConvertEvent_Timed** — create a `calendar.Event` with `Start.DateTime = "2026-02-14T10:00:00+02:00"`, `End.DateTime = "2026-02-14T11:00:00+02:00"`, verify:
   - `AllDay == false`
   - `Date == "2026-02-14"` (derived from Start in event's timezone)
   - `Start` is not zero, has correct hour
   - `End` is not zero

3. **TestConvertEvent_CopiesFields** — verify ID, Summary, Status are copied from the Google event.

4. **TestMergeEvents_Upsert** — existing events [A, B], delta with updated B and new C → result has [A, updated-B, C].

5. **TestMergeEvents_Cancelled** — existing events [A, B], delta with B status="cancelled" → result has only [A].

Note: `convertEvent` is unexported, but tests are in the same package (`google`) so they can access it directly.
Import `google.golang.org/api/calendar/v3` in tests to construct test `calendar.Event` structs.
  </action>
  <verify>
Run `go test ./internal/google/... -v` — all tests pass.
  </verify>
  <done>5 test functions pass covering all-day events, timed events, field copying, merge upsert, and merge cancellation.</done>
</task>

</tasks>

<verification>
- `go build ./internal/google/...` compiles cleanly
- `go vet ./internal/google/...` reports no issues
- `go test ./internal/google/... -v` — all tests pass
- `grep -c "SingleEvents(true)" internal/google/events.go` returns at least 1
- `grep -c "ShowDeleted(true)" internal/google/events.go` returns at least 1
- `grep -c "410" internal/google/events.go` returns at least 1 (GONE handling)
- CalendarEvent.Date is a string field (no time.Time for all-day dates)
</verification>

<success_criteria>
- CalendarEvent type exported and decoupled from Google API
- FetchEvents handles both full sync and delta sync with syncToken
- 410 GONE automatically retries with full sync
- All-day events stored as "YYYY-MM-DD" string (no timezone conversion)
- SingleEvents(true) used for recurring event expansion
- Bubble Tea commands (FetchEventsCmd, ScheduleEventTick) and messages (EventsFetchedMsg, EventTickMsg) exported
- MergeEvents handles upsert and cancellation
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/34-event-fetching-async/34-01-SUMMARY.md`
</output>

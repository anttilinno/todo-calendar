---
phase: 34-event-fetching-async
plan: 02
type: execute
wave: 2
depends_on: ["34-01"]
files_modified:
  - internal/app/model.go
  - main.go
autonomous: true

must_haves:
  truths:
    - "Events from Google Calendar appear in app state after startup"
    - "Events update automatically every 5 minutes without TUI freeze"
    - "Network errors preserve last known events — no crash, no blank screen"
    - "Fetch only runs when googleAuthState == AuthReady"
    - "Auth completion (AuthResultMsg success) triggers immediate first fetch"
  artifacts:
    - path: "internal/app/model.go"
      provides: "Calendar service field, event state, Update handlers for EventsFetchedMsg and EventTickMsg"
      contains: "EventsFetchedMsg"
    - path: "main.go"
      provides: "Calendar service initialization at startup when auth is ready"
  key_links:
    - from: "internal/app/model.go"
      to: "internal/google/events.go"
      via: "FetchEventsCmd and ScheduleEventTick commands"
      pattern: "google\\.FetchEventsCmd|google\\.ScheduleEventTick"
    - from: "internal/app/model.go"
      to: "internal/google/events.go"
      via: "EventsFetchedMsg and EventTickMsg message handling"
      pattern: "google\\.EventsFetchedMsg|google\\.EventTickMsg"
    - from: "internal/app/model.go"
      to: "internal/google/events.go"
      via: "MergeEvents for incremental sync"
      pattern: "google\\.MergeEvents"
---

<objective>
Wire Google Calendar event fetching into the Bubble Tea app model with startup fetch, 5-minute polling, error resilience, and auth-ready gating.

Purpose: Connect the events data layer (Plan 01) to the TUI lifecycle so events are fetched asynchronously and kept fresh without freezing the UI.
Output: Modified `internal/app/model.go` and `main.go` with full async event integration.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-event-fetching-async/34-RESEARCH.md
@.planning/phases/34-event-fetching-async/34-01-SUMMARY.md
@internal/google/auth.go
@internal/google/events.go
@internal/app/model.go
@main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add event state fields and startup initialization to app model</name>
  <files>internal/app/model.go, main.go</files>
  <action>
Modify `internal/app/model.go`:

1. **Add fields to Model struct:**
   ```go
   calendarSvc     *calendar.Service // nil if auth not ready; import google.golang.org/api/calendar/v3
   calendarEvents  []google.CalendarEvent
   eventsSyncToken string
   eventsFetchErr  error
   ```

2. **Update New() function** — accept an optional `*calendar.Service` parameter (add to signature):
   ```go
   func New(...existing params..., calSvc *calendar.Service) Model
   ```
   Store `calSvc` in `calendarSvc` field. Pass nil when auth is not ready.

3. **Update Init()** — if `calendarSvc != nil`, return a batch of `google.FetchEventsCmd(m.calendarSvc, "")` and `google.ScheduleEventTick()`. If calendarSvc is nil but auth might become ready later, still return `google.ScheduleEventTick()` so the tick loop runs:
   ```go
   func (m Model) Init() tea.Cmd {
       var cmds []tea.Cmd
       if m.calendarSvc != nil {
           cmds = append(cmds, google.FetchEventsCmd(m.calendarSvc, ""))
       }
       cmds = append(cmds, google.ScheduleEventTick())
       return tea.Batch(cmds...)
   }
   ```
   NOTE: Only start the tick if googleAuthState is AuthReady or if calendarSvc is set. If auth is AuthNotConfigured, do NOT start the polling loop (no point). Return nil if no Google Calendar configured.

4. **Update main.go** — after checking auth state, if `authState == google.AuthReady`, create calendar service:
   ```go
   var calSvc *calendar.Service
   if authState == google.AuthReady {
       calSvc, _ = google.NewCalendarService() // ignore error, calSvc stays nil
   }
   ```
   Pass `calSvc` to `app.New(...)`.

IMPORTANT: Keep the existing `app.New` signature backward-compatible by adding `calSvc` as the last parameter. Update the call site in main.go accordingly.
  </action>
  <verify>
Run `go build ./...` — must compile without errors.
  </verify>
  <done>Model has calendar event fields, Init fires fetch on startup when auth is ready, main.go creates calendar service.</done>
</task>

<task type="auto">
  <name>Task 2: Add Update handlers for event fetch messages and auth-ready trigger</name>
  <files>internal/app/model.go</files>
  <action>
Add message handling in the `Update()` method's top-level switch (alongside existing `google.AuthResultMsg` case):

1. **Handle google.EventsFetchedMsg:**
   ```go
   case google.EventsFetchedMsg:
       if msg.Err != nil {
           m.eventsFetchErr = msg.Err
           // FETCH-05: Keep last known calendarEvents intact, schedule retry
           return m, google.ScheduleEventTick()
       }
       m.eventsFetchErr = nil
       if m.eventsSyncToken == "" {
           // Full sync: replace all events
           m.calendarEvents = msg.Events
       } else {
           // Incremental sync: merge changes
           m.calendarEvents = google.MergeEvents(m.calendarEvents, msg.Events)
       }
       m.eventsSyncToken = msg.SyncToken
       return m, google.ScheduleEventTick()
   ```

2. **Handle google.EventTickMsg:**
   ```go
   case google.EventTickMsg:
       if m.calendarSvc == nil || m.googleAuthState != google.AuthReady {
           return m, google.ScheduleEventTick() // Skip, retry next tick
       }
       return m, google.FetchEventsCmd(m.calendarSvc, m.eventsSyncToken)
   ```

3. **Enhance existing AuthResultMsg handler** — when auth succeeds AND calendarSvc is nil, create the service and trigger immediate fetch:
   ```go
   case google.AuthResultMsg:
       if msg.Success {
           m.googleAuthState = google.AuthReady
           m.settings.SetGoogleAuthState(google.AuthReady)
           // Create calendar service and trigger first fetch
           if m.calendarSvc == nil {
               if svc, err := google.NewCalendarService(); err == nil {
                   m.calendarSvc = svc
                   return m, tea.Batch(
                       google.FetchEventsCmd(svc, ""),
                       google.ScheduleEventTick(),
                   )
               }
           }
       } else {
           m.googleAuthState = google.AuthNeedsLogin
           m.settings.SetGoogleAuthState(google.AuthNeedsLogin)
       }
       return m, nil
   ```

4. **Add a public accessor** for Phase 35 to use later:
   ```go
   func (m Model) CalendarEvents() []google.CalendarEvent {
       return m.calendarEvents
   }
   ```

IMPORTANT: The EventsFetchedMsg and EventTickMsg cases must be in the top-level switch (before overlay routing) because these messages arrive from tea.Cmd goroutines regardless of which overlay is open.
  </action>
  <verify>
Run `go build ./...` — must compile without errors.
Run `go vet ./...` — no warnings.
Manually verify: grep for `EventsFetchedMsg` in model.go to confirm handler exists.
Manually verify: grep for `EventTickMsg` in model.go to confirm handler exists.
Manually verify: grep for `ScheduleEventTick` in model.go to confirm polling is wired.
  </verify>
  <done>
App model handles EventsFetchedMsg (with full/incremental merge), EventTickMsg (with auth guard), and AuthResultMsg triggers first fetch.
Network errors preserve last known events. Polling runs every 5 minutes when auth is ready.
`go build ./...` and `go vet ./...` pass cleanly.
  </done>
</task>

</tasks>

<verification>
- `go build ./...` compiles the entire project cleanly
- `go vet ./...` reports no issues
- `go test ./...` — all existing tests still pass
- `grep "EventsFetchedMsg" internal/app/model.go` — handler exists
- `grep "EventTickMsg" internal/app/model.go` — handler exists
- `grep "ScheduleEventTick" internal/app/model.go` — polling wired
- `grep "MergeEvents" internal/app/model.go` — incremental merge used
- `grep "NewCalendarService" main.go` — service created at startup
- Auth-ready guard: EventTickMsg handler checks `m.googleAuthState != google.AuthReady`
- Error resilience: EventsFetchedMsg.Err preserves existing calendarEvents
</verification>

<success_criteria>
- Events fetched on startup when auth is ready (FETCH-01)
- 5-minute polling via ScheduleEventTick (FETCH-02)
- Incremental sync via MergeEvents when syncToken exists (FETCH-03)
- Events stored in-memory on Model struct (FETCH-04)
- Network errors preserve last known data, no crash (FETCH-05)
- Auth completion triggers immediate first fetch
- TUI never freezes — all fetches run via tea.Cmd
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/34-event-fetching-async/34-02-SUMMARY.md`
</output>

---
phase: 37-tui-state-file-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/app/model.go
  - main.go
autonomous: true
requirements: [BAR-04, BAR-05]

must_haves:
  truths:
    - "TUI writes state file on startup so Polybar reflects current state when the app opens"
    - "Adding a todo in the TUI immediately updates the state file"
    - "Completing (toggling) a todo in the TUI immediately updates the state file"
    - "Deleting a todo in the TUI immediately updates the state file"
    - "Editing a todo in the TUI immediately updates the state file"
    - "State file output format is identical to what the status subcommand produces"
  artifacts:
    - path: "internal/app/model.go"
      provides: "refreshStatusFile method on app.Model"
      contains: "refreshStatusFile"
    - path: "main.go"
      provides: "theme.Theme passed to app.New for status file writes"
      contains: "app.New"
  key_links:
    - from: "internal/app/model.go"
      to: "internal/status/status.go"
      via: "refreshStatusFile calls status.FormatStatus + status.WriteStatusFile"
      pattern: "status\\.FormatStatus|status\\.WriteStatusFile"
    - from: "internal/app/model.go"
      to: "internal/store/iface.go"
      via: "refreshStatusFile queries store.TodosForDateRange for today's todos"
      pattern: "TodosForDateRange"
---

<objective>
Wire the status file refresh into the TUI so Polybar stays current while the app is running.

Purpose: Without this, the state file only updates when the user manually runs `todo-calendar status`. With this, every todo mutation (add, toggle, delete, edit) and app startup triggers an immediate state file write, keeping Polybar's display in sync.

Output: Modified `internal/app/model.go` with `refreshStatusFile` method called on startup and after every todo update cycle. Modified `main.go` to pass theme to the app model.
</objective>

<execution_context>
@/home/antti/.claude/get-shit-done/workflows/execute-plan.md
@/home/antti/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-status-subcommand/36-01-SUMMARY.md
@.planning/phases/36-status-subcommand/36-02-SUMMARY.md
@internal/app/model.go
@internal/status/status.go
@main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add refreshStatusFile method and wire into app.Model startup</name>
  <files>internal/app/model.go, main.go</files>
  <action>
1. Add a `theme theme.Theme` field to the `app.Model` struct. This stores the current theme for use by `refreshStatusFile` without needing to re-derive it from config on every call.

2. Update `app.New()` to accept a `theme.Theme` parameter and store it on the model. The signature becomes:
   `func New(provider *holidays.Provider, mondayStart bool, s store.TodoStore, t theme.Theme, cfg config.Config, authState google.AuthState, calSvc *gcal.Service) Model`
   Note: the function already receives `t theme.Theme` — just store it: `theme: t` in the returned Model literal.

3. Update `applyTheme()` to also update `m.theme = t` so theme changes (from settings) are reflected in status writes.

4. Add the `refreshStatusFile` method to `app.Model`:
   ```go
   func (m *Model) refreshStatusFile() {
       today := time.Now().Format("2006-01-02")
       todos := m.store.TodosForDateRange(today, today)
       output := status.FormatStatus(todos, m.theme)
       _ = status.WriteStatusFile(output)
   }
   ```
   Errors are silently ignored — the status file is a best-effort side effect (Polybar will just show stale data). Import `"time"` and `"github.com/antti/todo-calendar/internal/status"` (status is already imported in main.go but needs to be added to app/model.go).

5. Wire `refreshStatusFile` at startup: In the `Init()` method, call `m.refreshStatusFile()` before returning. This ensures the state file exists when the TUI starts (BAR-05). Note: Init returns tea.Cmd, so call refreshStatusFile for its side effect before the existing return:
   ```go
   func (m Model) Init() tea.Cmd {
       m.refreshStatusFile()
       // ... existing code
   }
   ```
   IMPORTANT: Init() has a value receiver `(m Model)` not pointer receiver. Since refreshStatusFile only needs to READ model fields (store, theme) and call external functions, this works fine. refreshStatusFile should also use a value receiver `(m Model)` for consistency.

6. Wire `refreshStatusFile` after every todolist update cycle: At the bottom of the `Update()` method, right after `m.calendar.RefreshIndicators()` (line ~402), add `m.refreshStatusFile()`. This catches ALL todo mutations (add, toggle, delete, edit title/date/priority, reorder) because they all flow through the todoPane branch of Update.

7. Wire `refreshStatusFile` after editor body edits: In the `editor.EditorFinishedMsg` handler, after the `m.store.UpdateBody()` call (line ~294-295), add `m.refreshStatusFile()`. Body edits via the external editor don't flow through the todoPane Update cycle, so they need explicit handling.

8. Wire `refreshStatusFile` after settings theme change: In the `settings.SettingChangedMsg` handler, after `m.applyTheme()` call (line ~146), add `m.refreshStatusFile()`. Theme changes affect the hex color in the status output.

9. In `main.go`, no changes needed — `app.New` already receives `t theme.Theme`.

Do NOT add `refreshStatusFile` calls in the todolist package — keep the status file concern in the app layer only.
  </action>
  <verify>
    <automated>cd /home/antti/Repos/Misc/todo-calendar/.dmux/worktrees/notifier && go build ./... && go test ./...</automated>
    <manual>Run `todo-calendar` (the TUI), then check that /tmp/.todo_status exists with correct Polybar format. Add a todo, verify file updates. Toggle it done, verify file becomes empty string.</manual>
  </verify>
  <done>app.Model has a refreshStatusFile method that queries today's todos, formats via status.FormatStatus, and writes via status.WriteStatusFile. Called on Init (BAR-05) and after every todolist update cycle, editor body edits, and theme changes (BAR-04).</done>
</task>

<task type="auto">
  <name>Task 2: Add integration test for refreshStatusFile wiring</name>
  <files>internal/status/status_test.go</files>
  <action>
Add a test to `internal/status/status_test.go` that verifies the end-to-end refresh path works correctly: FormatStatus + writeStatusFileTo combined. This doesn't test the Bubble Tea wiring (which would require complex mocking) but validates the core operation that refreshStatusFile performs.

Add test `TestRefreshStatusFileEndToEnd`:
```go
func TestRefreshStatusFileEndToEnd(t *testing.T) {
    th := theme.ForName("catppuccin")

    // Simulate what refreshStatusFile does: query todos, format, write
    todos := []store.Todo{
        {Text: "Buy milk", Date: "2026-02-23", Done: false, Priority: 2},
        {Text: "Call dentist", Date: "2026-02-23", Done: true, Priority: 1},
    }
    output := FormatStatus(todos, th)

    tmpFile := filepath.Join(t.TempDir(), ".todo_status")
    err := writeStatusFileTo(output, tmpFile)
    if err != nil {
        t.Fatalf("writeStatusFileTo failed: %v", err)
    }

    data, err := os.ReadFile(tmpFile)
    if err != nil {
        t.Fatalf("read file failed: %v", err)
    }

    got := string(data)
    if got != output {
        t.Errorf("file content = %q, want %q", got, output)
    }

    // Verify the output matches expected format (one pending todo with P2)
    if output == "" {
        t.Error("expected non-empty output for pending todo")
    }
    if !strings.Contains(output, "%{F") {
        t.Error("expected Polybar color formatting")
    }
}
```

Also add a test that verifies an "all done" refresh produces an empty file:
```go
func TestRefreshStatusFileAllDone(t *testing.T) {
    th := theme.ForName("catppuccin")

    todos := []store.Todo{
        {Text: "Done task", Date: "2026-02-23", Done: true, Priority: 1},
    }
    output := FormatStatus(todos, th)

    tmpFile := filepath.Join(t.TempDir(), ".todo_status")
    err := writeStatusFileTo(output, tmpFile)
    if err != nil {
        t.Fatalf("writeStatusFileTo failed: %v", err)
    }

    data, _ := os.ReadFile(tmpFile)
    if string(data) != "" {
        t.Errorf("expected empty file for all-done todos, got %q", string(data))
    }
}
```

Import `"strings"` and `"path/filepath"` if not already present.
  </action>
  <verify>
    <automated>cd /home/antti/Repos/Misc/todo-calendar/.dmux/worktrees/notifier && go test ./internal/status/ -run TestRefreshStatusFile -v</automated>
  </verify>
  <done>Two integration tests verify that the FormatStatus + writeStatusFileTo pipeline produces correct state file content for both active-todo and all-done scenarios.</done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds (no compilation errors)
2. `go test ./...` passes (all existing tests + new integration tests)
3. `grep -n "refreshStatusFile" internal/app/model.go` shows method definition + 4 call sites (Init, Update bottom, EditorFinishedMsg, SettingChangedMsg)
4. `grep -n "theme theme.Theme" internal/app/model.go` shows the theme field on Model struct
</verification>

<success_criteria>
- BAR-04: Every todo mutation path in the TUI (add, toggle, delete, edit, body edit, reorder) triggers refreshStatusFile
- BAR-05: TUI startup (Init) triggers refreshStatusFile before returning
- State file format is identical to `todo-calendar status` output (uses same FormatStatus + WriteStatusFile functions)
- No regressions: all existing tests pass
- New integration tests validate the end-to-end refresh path
</success_criteria>

<output>
After completion, create `.planning/phases/37-tui-state-file-integration/37-01-SUMMARY.md`
</output>
